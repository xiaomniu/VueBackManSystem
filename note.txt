Node.js 是一个跨平台 Javascript 运行环境，相当于一个浏览器，使开发者可以搭建服务端的 Javascript 应用程序
    后端程序：提供接口和数据
    前端工程化：对代码压缩，转译，整合（使用各种工具，提升效率）
指定安装 node-v16.19.0.msi 版本(为了兼容 后期学习的项目)
下载地址：https://nodejs.org/download/release/v16.19.0/
    默认情况下，我们在执行npm install -g XXXX下载全局包时，这个包的
        默认存放路径位C:\Users\用户名\AppData\Roaming\npm\node_modules下，可以通过CMD指令npm root -g查看
    自定义存放目录,在CMD窗口执行以下两条命令修改默认路径
        npm config set prefix "C:\Program Files\nodejs\node_global"
        npm config set cache "C:\Program Files\nodejs\node_cache"
        或者 打开 C:\Program Files\nodejs\node_modules\npm\.npmrc 文件，修改如下：
            prefix =C:\Program Files\nodejs\node_global
            cache = C:\Program Files\nodejs\node_cache

        设置镜像源：npm config set registry https://registry.npmmirror.com
        查看下是否设置成功：npm config get registry
        
        npm i pnpm -g



Vue 包 官网：v2.cn.vuejs.org
这里引入包： <script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"></script> -->
Vue.js devtools 下载: 国内地址：https://chrome.zzzmh.cn/（极简插件）
    下载完压缩包后，将里面的 *.crx 插件文件，拖入 在谷歌浏览器中 的扩展程序安装的地方 安装好后。点击插件上的 “详情” 按钮，将里面的 “允许访问文件网址” 选项开关  打开。

************** Day01 **************
指令：
    v-html = "str"， 设置 元素的 innerHTML
    v-show = "表达式"，表达的结果必须是 true 或 false，true就显示，false就隐藏。切换 display:none 来控制 显示隐藏，频繁切换 显示场景
    v-if   = "表达式"，表达的结果必须是 true 或 false，true就显示，控制元素 显示/隐藏 （条件渲染）。基于条件判断，是否 创建 或 移除 元素节点。 不频繁 切换显示场景

    v-on，注册事件=添加监听+提供处理逻辑。
        v-on:事件名="内联语句"  
        v-on:事件名="method中的函数名"。
        简写 v-on:事件名 => @事件名
        method函数中的 this 指向的是 当前的 Vue 实例
    v-bind，动态设置 html 标签属性（如 src url title href 。。。）
        v-bind:属性名="表达式"
        简写 v-bind:属性名 => :属性名
    v-for，基于 数据循环，多次渲染整个元素 --> 数组、对象、数字 ...
        v-for = "(item,index) in 数组" :key="唯一标识"
            item 表示每一项，index 表示下标
            如果 用不到 index 只用到 item，则可以 使用省略写法：v-for = "item in 数组"
            key，给列表添加一个唯一标识。便于Vue进行列表项的正确排序复用
    v-model，只给 表单元素 使用，双向数据绑定 -> 可以快速 获取 或 设置 表单元素内容
        只有表单元素才能 收集 用户 的 输入
        1. 数据变化 -> 视图自送更新
        2. 视图变化 -> 数据自动更新

************** Day02 **************
    数组中的元素改变 会触发界面重新渲染的 7中情况：push pop shift unshift splice sort reverse，都会改变原数组
        Vue.$set(arr, index, content) 封装了 arr.splice(index, 1, content)

    指令修饰符
    指令修饰符 只用在 事件(普通事件 和 键盘事件) 和 v-model 上使用
        键盘事件
            @keyup.enter               只有键盘事件都可以使用
            @keydown.esc               只有键盘事件都可以使用
        普通事件
            @事件名.stop 组织冒泡               所有事件都可以使用
            @事件名.prevent 阻止默认行为        所有事件都可以使用
        v-model
            v-model.trim 去除首尾空格
            v-model.number 转数字

    v-bind 对应标签的 样式  增强 操作性
    v-bind 针对 class类名  和  style行内样式  进行控制
        语法：:class="对象/数组"
        对象 -> 键就是类名，值是 布尔值。如果为 true，就加入class属性值中，否则 不加入 class属性值中
        <div class="box" :class="{类名1: 布尔值, 类名2: 布尔值}"></div>
        数组 -> 数组中所有的类，都会添加到盒子上的 class属性值中，本质就是一个class列表
        <div class="box" :class="[类名1, 类名2, 类名3]"></div>

        语法：:style="样式对象"
        适用于 某个 具体属性 的动态设置
        <div class="box" :style="{ CSS属性名1: CSS属性值, CSS属性名2: CSS属性值, CSS属性名3: CSS属性值}"></div>
        
    v-model 也 可以用在  文本框  单选框  复选框  文本域  下拉框
        常见的表单元素都可以用 v-model 绑定关联  --> 快速  获取  或  设置  表单元素的值
        他会根据  控件类型  自动选取  正确的方法  来更新元素
            文本框  input:text          绑定   value
            文本域  textarea            绑定   value
            复选框  input:checkbox      绑定   checked
            单选框  input:radio         绑定   checked
            下拉框  select              绑定   value

    computed 计算属性
        基于 现有的数据， 计算出来的 新属性。依赖  的数据变化， 自动  重新计算
        语法基础 / 计算属性 vs 方法 / 完整写法 / 成绩案例

    watch 侦听器（监视器）
        监视数据变化，执行一些业务逻辑 或 异步操作
        语法基础 / 完整写法 / 案例



传智教育-vue基础案例  测试接口:
https://apifox.com/apidoc/shared-24459455-ebb1-4fdc-8df8-0aff8dc317a8
************** Day03 **************
    Vue 生命周期 和 生命周期的 四个阶段
        Vue 什么时候可以 发送 初始化渲染请求？          -> 应该越早越好，但要在 Vue 自己的数据(如 data:{} 域中的数据) 初始化完成 后
        Vue 什么时候可以 开始 操作Dom？                -> 至少得 Dom渲染 出来的时候 才可以        
        Vue生命周期：
            一个 Vue实例从 创建 到 销毁 的整个过程。
            创建：New Vue()
            1. 创建阶段：初始化 data:{} 域中的数据，处理成响应式特点的数据
                beforeCreate()  ：创建前 回调函数
                created()       ：创建后 回调函数，此时 Vue 应该在这个时间 进行 发送 初始化 渲染请求
            2. 挂在阶段：将用户编写的 渲染模板代码 转化为 真正的 Html代码
                beforeMount()   : 挂载前 回调函数
                Mounted()       : 挂载后 回调函数，此时 Vue 应该在这个时间 进行 开始操作Dom
            3. 更新阶段：只要 修改了Vue里的相应的数据 就会不断 的进行 更新视图，一直重复这个过程
                beforeUpdate()  : 更新前 回调函数
                Updated()       : 更新后 回到函数
            4. 销毁阶段：app.$destroy() 可以手动触发 Vue实例 的销毁，一旦执行后，Vue之前的所有相关机制将不再正常使用
                beforeDestroy() : 销毁前 回调函数
                destroyed()     : 销毁后 回调函数

    Vue 生命周期 钩子案例
        新闻列表：希望 页面一加载 就把 数据渲染出来
        输入框自动聚焦：页面一加载 自动 定位 到 输入框，将输入框 成为 焦点

    Vue Cli 脚手架
        使用步骤：
        1. 全局安装（一次）：npm i @vue/cli@5.0.8 -g
        2. 查看 Vue 版本：vue --version
        3. 创建项目架子：vue create project-name（项目-不能用中文）
        4. 启动项目：npm run server（找到 package.json）

    脚手架 目录文件介绍
        VUE-DEMO
            node_modules            第三方包文件夹                         (目录)
            publi                   放 html 文件的地方                     (目录)
                favicon.ico         网站图标
                index.html          index.html 模板文件                               （*** 3 ***）
            src                     源代码目录 --> 以后写代码的文件夹       (目录)
                assets              静态资源目录 --> 存放 图片、字体等
                components          组件目录 --> 存放通用组件
                App.vue             App 根组件  --> 项目运行看到的内容就在这里编写      （*** 2 ***）
                main.js             入口文件  --> 打包或运行，第一个执行的文件          （*** 1 ***）
            .gitignore              git忽略文件
            babel.config.js         babel配置文件（配置 js 怎么去降级）
            jsconfig.json           js配置文件
            package.json            项目配置文件  --> 包含项目名、版本号、scripts、依赖包 等
            README.md               项目说明文档
            vue.config.js           vue-cli 配置文件
            yarn.lock               yarn锁文件，有 yarn 自动生成的，锁定安装版本（如果使用的是 npm 生成的工程，这个锁文件则是 package-lock.json

        项目运行流程
            npm run server 首先 找 main.js 文件，
            main.js 文件中 会有以下几部分：
                1. 导入 vue
                    import Vue from 'vue'
                2. 导入 App.vue
                    import App from './App.vue'
                3. 实例化 一个 Vue 对象，将 App.vue 渲染到 index.html 容器中
                    new Vue({
                        render: h=> h(App),
                    }).$mount('#app')

    组件化开发 & 根组件
        组件化：一个页面可以拆分成一个个组件，每个组件有着自己的独立的  结构、样式、行为
            便于 维护，利于 复用
            组件分为： 根组件  和  普通组件
        根组件：整个 应用最上层的组件，包裹 所有 普通小组件
    App根组件
        头部组件
        导航组件
        主体组件
            商品组件01
            商品组件02
            ...
        底部组件
    
    App.vue文件（单文件 组件）的 三个 组成部分
        结构：templete（有且只能有一个肯元素）
        样式：style（可支持less，需要装包）
            让组件支持less
                1. style标签，lang="less" 开启less功能
                2. 装包：npm i less less-loader@5 -D
        行为：js逻辑

    普通组件 的 注册使用
    组件 注册的两种方式：
        1. 局部注册：只能在注册的组件内使用
            创建 .vue 文件（三个部分  template script style）
            在使用的组件内导入并注册
        使用步骤：
            当成 html 标签使用 `<组件名></组件名>`
            如下：
                import 组件对象 from '.vue文件路径'
                import HmHeader from './components/HmHeader'
                export default {
                    // 局部注册
                    components:{
                        '组件名':组件对象,
                        HmHeader:HmHeader
                    }
                }
        注意：
            组件名规范 --> 大驼峰命名法，如： HmHeader
            
        2. 全局注册：所有组件内都能使用
            创建 .vue 文件（三个部分 template script style）
            main.js 中进行全局注册
        使用步骤：
            当成 html 标签使用 `<组件名></组件名>`
            在 main.js 文件中 进行 如下：
                // 导入需要全局注册的组件
                import HmButton from './components/HmButton'
                // 调用 Vue.component 进行全局注册
                // Vue.component('组件名', 组件对象)
                Vue.component('HmButton', HmButton)
        注意：
            组件名规范 --> 大驼峰命名法，如 HmButton


************** Day04 **************
    组件的三大组成不分（结构/样式/逻辑）
        scoped样式冲突 / data 是一个函数
    组件通信
        组件通信语法 / 父传子 / 子传父 / 非父子间传递
    综合案例：小黑记事本（组件版）
        拆分组件 / 渲染 / 添加 / 删除 / 统计 / 清空 / 持久化
    进阶语法
        v-model原理 / v-model应用于组件 / sync修饰符 / ref 和 $ref / $nextTick

    结构：<templete>（有且只能有一个肯元素）
    样式：<style>
        全局样式（默认）：影响所有组件
        局部样式：scoped下样式，只作用于当前组件
    逻辑：<script>
        el 根实例独有，
        data 是一个函数
        其他配置项 都和以前一样
    
    scoped 解决样式冲突
        默认情况：写在组件中的样式会全局生效 --> 因此很容易造成多个组之间的样式冲突问题
        1. 全局样式：默认组件中的样式会作用到全局
        2. 局部样式：可以给组件加上 scoped 属性，可以让样式只作用于当前组件
        scoped 原理：
            1. 当前组件内都被添加 data-v-hash 值的属性
            2. css 选择器都被添加 [data-v-hash值] 的属性选择器
            最终效果：必须是当前组件的元素，才会有这个自定义属性，才会被这个样式 作用到
    
    data 是一个函数
        一个组件的 data 选项必须是一个函数 --> 保证每个组件实例，维护 独立 的一份数据对象。
        每次创建新的组件实例，都会新执行一次 data 函数，得到一个新对象。

    组件通信
    组件间通信，就是指 组件与组件 之间 的数据传递
    1. 组件的数据是独立的，无法直接访问其他组件的数据
    2. 想用其他组件的数据 就需要使用  组件通信  技术
    组件间的通信方案
        组件间的关系：父子关系  和  非父子关系
        父子关系：
            props：父 向 子 传递数据
            $emit：子 向 父 传递数据
        非父子关系：
            provide & inject
            eventbus（事件总线）
        通用解决方案：Vuex（适合复杂业务场景）
            
    什么是 prop
        prop 定义：组件上注册的一些 自定义属性
        prop 作用：向子组件传递数据
        特点：
            可以传递 任意数量 的 prop
            可以传递 任意类型 的 prop
    prop 校验
        为组件的 prop 指定 验证要求，不符合要求，控制台 就会有 错误提示，以便于 开发着，快速发现错误
        语法：
            1. 类型校验
                props:{
                    校验的属性名 : 类型 // Number  String  Boolen Array Object ...
                }
            2. 非空校验
            3. 默认值
            4. 自定义校验
                // 完整的 校验语法
                props:{
                    校验的属性名 : {
                        type : 类型,            // Number  String  Boolen Array Object ...
                        required : true,        // 是否必填
                        default : 默认值,        // 默认值
                        validator (value) {     // 自定义校验逻辑
                            return 是否通过校验
                        }
                    }
                }
    
    prop & data 、单项数据流
        共同点：都可以给组件提供数据。
        区别：
            data 的数据 都是自己的，可以 随便改
            prop 的数据 是外部的，不能 直接改，要遵循  单向数据流
        单向数据流：父级 prop 的数据更新，会向下流动，影响子组件。这个数据流动是 单向的。（谁的数据谁负责）
    
    v-model原理
        v-model 本质上是一个 语法糖，例如应用在输入框上，就是 value属性 和 input事件 的合写
        作用：提供 数据的双向绑定
            数据变：视图跟着变 :value
            视图变：数据跟着变 @input
            <template>
                <div id="app">
                    <input v-model="msg" type="text">
                    <input :value="msg" @input="msg=$event.target.value" type="text">
                </div>
            </template>

    表单类组件封装
        1. 表单类组件 封装 --> 实现 子组件 和 父组件数据 的双向绑定
        父传子：数据 应该是父组件 props 传递 过来的，拆解 v-model 绑定数据
        子传父：监听输入，子传父值 给 父组件修改
        <BaseSelect :cityId="selectId" @事件名="selectId=$event">...</BaseSelect>
        <select :value="cityId" @change="handleChange">...</select>
        props:{
            cityId:String
        },
        methods:{
            handleChange(e){
                this.$emit("事件名", e.target.value)
            }
        }

    表单类组件封装 v-model 简化代码
        2. 父组件 v-model简化代码，实现 子组件 和 父组件 数据 双向绑定
        子组件中：props 通过 value 接收，事件触发 input
        父组件中：v-model 给组件直接绑定数据
        <select :value="value" @change="handleChange">...</select>
        props:{
            value : String
        },
        methods:{
            handleChange(e){
                this.$emit('input', e.target.value)
            }
        }

    v-model 的局限性：
        1. 数据名 必须叫 value
        2. 事件名 必须叫 input
        3. 一个标签只能使用一次 v-model
        
    .sync 修饰符 （可以解决 v-model 的局限性）
        作用：可以实现 子组件 与 父组件数据 的 双向绑定，简化代码
        特点：
            prop属性名，可以 自定义，不局限于叫 value。
            事件名，可以 自定义，不局限于叫 input
        
        本质：就是 :属性名  和  @update:属性名  合写

        场景：封装弹框类的基础组件，自定义属性名为visible，用 true表示显示，false表示隐藏
        <BaseDialog : visible.sync="isShow" >
        <BaseDialog : visible="isShow" @update:visible="isShow=$event"
        Props:{
            visible : Boolean
        },
        this.$emit('update:visible', false)

    ref 和 $ref
        作用：利用 ref 和 $ref 可以用于 获取 Dom元素 或 组件实例
        特点：查找范围 --> 当前组件内（更精确稳定）
        获取Dom元素：
            老方法：document.querySelector('input')（查找范围是 整个页面的第一个匹配上的元素）
            新方法：
                1. 目标标签 - 添加 ref 属性
                <div ref="chartRef"> 我是渲染图表容器 </div>
                2. 恰当时机，通过 this.$refs.xxx，获取目标标签
                mounted(){
                    console.log(this.$refs.chartRef)
                }
    Vue 异步更新、$nextTick
        Vue 中的 数据更新  和  视图渲染  任务  是异步的。所以 会导致 数据变化后，需要更新的 Dom元素还没有 渲染出来，
            此时 无法正确的操作到 Dom元素。
        为了 解决这个问题，Vue 提供了 $nextTick() 回调函数，可以在视图更新后 第一时间 运行 设置好的 回调函数，在这
            个时机  进行Dom元素操作 是正常的。
