Node.js 是一个跨平台 Javascript 运行环境，相当于一个浏览器，使开发者可以搭建服务端的 Javascript 应用程序
    后端程序：提供接口和数据
    前端工程化：对代码压缩，转译，整合（使用各种工具，提升效率）
指定安装 node-v16.19.0.msi 版本(为了兼容 后期学习的项目)
下载地址：https://nodejs.org/download/release/v16.19.0/
    默认情况下，我们在执行npm install -g XXXX下载全局包时，这个包的
        默认存放路径位C:\Users\用户名\AppData\Roaming\npm\node_modules下，可以通过CMD指令npm root -g查看
    自定义存放目录,在CMD窗口执行以下两条命令修改默认路径
        npm config set prefix "C:\Program Files\nodejs\node_global"
        npm config set cache "C:\Program Files\nodejs\node_cache"
        或者 打开 C:\Program Files\nodejs\node_modules\npm\.npmrc 文件，修改如下：
            prefix =C:\Program Files\nodejs\node_global
            cache = C:\Program Files\nodejs\node_cache

        设置镜像源：npm config set registry https://registry.npmmirror.com
        查看下是否设置成功：npm config get registry
        
        npm i pnpm -g



Vue 包 官网：v2.cn.vuejs.org
这里引入包： <script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"></script> -->
Vue.js devtools 下载: 国内地址：https://chrome.zzzmh.cn/（极简插件）
    下载完压缩包后，将里面的 *.crx 插件文件，拖入 在谷歌浏览器中 的扩展程序安装的地方 安装好后。点击插件上的 “详情” 按钮，将里面的 “允许访问文件网址” 选项开关  打开。

************** Day01 **************
指令：
    v-html = "str"， 设置 元素的 innerHTML
    v-show = "表达式"，表达的结果必须是 true 或 false，true就显示，false就隐藏。切换 display:none 来控制 显示隐藏，频繁切换 显示场景
    v-if   = "表达式"，表达的结果必须是 true 或 false，true就显示，控制元素 显示/隐藏 （条件渲染）。基于条件判断，是否 创建 或 移除 元素节点。 不频繁 切换显示场景

    v-on，注册事件=添加监听+提供处理逻辑。
        v-on:事件名="内联语句"  
        v-on:事件名="method中的函数名"。
        简写 v-on:事件名 => @事件名
        method函数中的 this 指向的是 当前的 Vue 实例
    v-bind，动态设置 html 标签属性（如 src url title href 。。。）
        v-bind:属性名="表达式"
        简写 v-bind:属性名 => :属性名
    v-for，基于 数据循环，多次渲染整个元素 --> 数组、对象、数字 ...
        v-for = "(item,index) in 数组" :key="唯一标识"
            item 表示每一项，index 表示下标
            如果 用不到 index 只用到 item，则可以 使用省略写法：v-for = "item in 数组"
            key，给列表添加一个唯一标识。便于Vue进行列表项的正确排序复用
    v-model，只给 表单元素 使用，双向数据绑定 -> 可以快速 获取 或 设置 表单元素内容
        只有表单元素才能 收集 用户 的 输入
        1. 数据变化 -> 视图自送更新
        2. 视图变化 -> 数据自动更新

************** Day02 **************
    数组中的元素改变 会触发界面重新渲染的 7中情况：push pop shift unshift splice sort reverse，都会改变原数组
        Vue.$set(arr, index, content) 封装了 arr.splice(index, 1, content)

    指令修饰符
    指令修饰符 只用在 事件(普通事件 和 键盘事件) 和 v-model 上使用
        键盘事件
            @keyup.enter               只有键盘事件都可以使用
            @keydown.esc               只有键盘事件都可以使用
        普通事件
            @事件名.stop 组织冒泡               所有事件都可以使用
            @事件名.prevent 阻止默认行为        所有事件都可以使用
        v-model
            v-model.trim 去除首尾空格
            v-model.number 转数字

    v-bind 对应标签的 样式  增强 操作性
    v-bind 针对 class类名  和  style行内样式  进行控制
        语法：:class="对象/数组"
        对象 -> 键就是类名，值是 布尔值。如果为 true，就加入class属性值中，否则 不加入 class属性值中
        <div class="box" :class="{类名1: 布尔值, 类名2: 布尔值}"></div>
        数组 -> 数组中所有的类，都会添加到盒子上的 class属性值中，本质就是一个class列表
        <div class="box" :class="[类名1, 类名2, 类名3]"></div>

        语法：:style="样式对象"
        适用于 某个 具体属性 的动态设置
        <div class="box" :style="{ CSS属性名1: CSS属性值, CSS属性名2: CSS属性值, CSS属性名3: CSS属性值}"></div>
        
    v-model 也 可以用在  文本框  单选框  复选框  文本域  下拉框
        常见的表单元素都可以用 v-model 绑定关联  --> 快速  获取  或  设置  表单元素的值
        他会根据  控件类型  自动选取  正确的方法  来更新元素
            文本框  input:text          绑定   value
            文本域  textarea            绑定   value
            复选框  input:checkbox      绑定   checked
            单选框  input:radio         绑定   checked
            下拉框  select              绑定   value

    computed 计算属性
        基于 现有的数据， 计算出来的 新属性。依赖  的数据变化， 自动  重新计算
        语法基础 / 计算属性 vs 方法 / 完整写法 / 成绩案例

    watch 侦听器（监视器）
        监视数据变化，执行一些业务逻辑 或 异步操作
        语法基础 / 完整写法 / 案例



传智教育-vue基础案例  测试接口:
https://apifox.com/apidoc/shared-24459455-ebb1-4fdc-8df8-0aff8dc317a8
************** Day03 **************
    Vue 生命周期 和 生命周期的 四个阶段
        Vue 什么时候可以 发送 初始化渲染请求？          -> 应该越早越好，但要在 Vue 自己的数据(如 data:{} 域中的数据) 初始化完成 后
        Vue 什么时候可以 开始 操作Dom？                -> 至少得 Dom渲染 出来的时候 才可以        
        Vue生命周期：
            一个 Vue实例从 创建 到 销毁 的整个过程。
            创建：New Vue()
            1. 创建阶段：初始化 data:{} 域中的数据，处理成响应式特点的数据
                beforeCreate()  ：创建前 回调函数
                created()       ：创建后 回调函数，此时 Vue 应该在这个时间 进行 发送 初始化 渲染请求
            2. 挂在阶段：将用户编写的 渲染模板代码 转化为 真正的 Html代码
                beforeMount()   : 挂载前 回调函数
                Mounted()       : 挂载后 回调函数，此时 Vue 应该在这个时间 进行 开始操作Dom
            3. 更新阶段：只要 修改了Vue里的相应的数据 就会不断 的进行 更新视图，一直重复这个过程
                beforeUpdate()  : 更新前 回调函数
                Updated()       : 更新后 回到函数
            4. 销毁阶段：app.$destroy() 可以手动触发 Vue实例 的销毁，一旦执行后，Vue之前的所有相关机制将不再正常使用
                beforeDestroy() : 销毁前 回调函数
                destroyed()     : 销毁后 回调函数

    Vue 生命周期 钩子案例
        新闻列表：希望 页面一加载 就把 数据渲染出来
        输入框自动聚焦：页面一加载 自动 定位 到 输入框，将输入框 成为 焦点

    Vue Cli 脚手架
        使用步骤：
        1. 全局安装（一次）：npm i @vue/cli@5.0.8 -g
        2. 查看 Vue 版本：vue --version
        3. 创建项目架子：vue create project-name（项目-不能用中文）
        4. 启动项目：npm run server（找到 package.json）

    脚手架 目录文件介绍
        VUE-DEMO
            node_modules            第三方包文件夹                         (目录)
            publi                   放 html 文件的地方                     (目录)
                favicon.ico         网站图标
                index.html          index.html 模板文件                               （*** 3 ***）
            src                     源代码目录 --> 以后写代码的文件夹       (目录)
                assets              静态资源目录 --> 存放 图片、字体等
                components          组件目录 --> 存放通用组件
                App.vue             App 根组件  --> 项目运行看到的内容就在这里编写      （*** 2 ***）
                main.js             入口文件  --> 打包或运行，第一个执行的文件          （*** 1 ***）
            .gitignore              git忽略文件
            babel.config.js         babel配置文件（配置 js 怎么去降级）
            jsconfig.json           js配置文件
            package.json            项目配置文件  --> 包含项目名、版本号、scripts、依赖包 等
            README.md               项目说明文档
            vue.config.js           vue-cli 配置文件
            yarn.lock               yarn锁文件，有 yarn 自动生成的，锁定安装版本（如果使用的是 npm 生成的工程，这个锁文件则是 package-lock.json

        项目运行流程
            npm run server 首先 找 main.js 文件，
            main.js 文件中 会有以下几部分：
                1. 导入 vue
                    import Vue from 'vue'
                2. 导入 App.vue
                    import App from './App.vue'
                3. 实例化 一个 Vue 对象，将 App.vue 渲染到 index.html 容器中
                    new Vue({
                        render: h=> h(App),
                    }).$mount('#app')

    组件化开发 & 根组件
        组件化：一个页面可以拆分成一个个组件，每个组件有着自己的独立的  结构、样式、行为
            便于 维护，利于 复用
            组件分为： 根组件  和  普通组件
        根组件：整个 应用最上层的组件，包裹 所有 普通小组件
    App根组件
        头部组件
        导航组件
        主体组件
            商品组件01
            商品组件02
            ...
        底部组件
    
    App.vue文件（单文件 组件）的 三个 组成部分
        结构：templete（有且只能有一个肯元素）
        样式：style（可支持less，需要装包）
            让组件支持less
                1. style标签，lang="less" 开启less功能
                2. 装包：npm i less less-loader@5 -D
        行为：js逻辑

    普通组件 的 注册使用
    组件 注册的两种方式：
        1. 局部注册：只能在注册的组件内使用
            创建 .vue 文件（三个部分  template script style）
            在使用的组件内导入并注册
        使用步骤：
            当成 html 标签使用 `<组件名></组件名>`
            如下：
                import 组件对象 from '.vue文件路径'
                import HmHeader from './components/HmHeader'
                export default {
                    // 局部注册
                    components:{
                        '组件名':组件对象,
                        HmHeader:HmHeader
                    }
                }
        注意：
            组件名规范 --> 大驼峰命名法，如： HmHeader
            
        2. 全局注册：所有组件内都能使用
            创建 .vue 文件（三个部分 template script style）
            main.js 中进行全局注册
        使用步骤：
            当成 html 标签使用 `<组件名></组件名>`
            在 main.js 文件中 进行 如下：
                // 导入需要全局注册的组件
                import HmButton from './components/HmButton'
                // 调用 Vue.component 进行全局注册
                // Vue.component('组件名', 组件对象)
                Vue.component('HmButton', HmButton)
        注意：
            组件名规范 --> 大驼峰命名法，如 HmButton


************** Day04 **************
    组件的三大组成不分（结构/样式/逻辑）
        scoped样式冲突 / data 是一个函数
    组件通信
        组件通信语法 / 父传子 / 子传父 / 非父子间传递
    综合案例：小黑记事本（组件版）
        拆分组件 / 渲染 / 添加 / 删除 / 统计 / 清空 / 持久化
    进阶语法
        v-model原理 / v-model应用于组件 / sync修饰符 / ref 和 $ref / $nextTick

    结构：<templete>（有且只能有一个肯元素）
    样式：<style>
        全局样式（默认）：影响所有组件
        局部样式：scoped下样式，只作用于当前组件
    逻辑：<script>
        el 根实例独有，
        data 是一个函数
        其他配置项 都和以前一样
    
    scoped 解决样式冲突
        默认情况：写在组件中的样式会全局生效 --> 因此很容易造成多个组之间的样式冲突问题
        1. 全局样式：默认组件中的样式会作用到全局
        2. 局部样式：可以给组件加上 scoped 属性，可以让样式只作用于当前组件
        scoped 原理：
            1. 当前组件内都被添加 data-v-hash 值的属性
            2. css 选择器都被添加 [data-v-hash值] 的属性选择器
            最终效果：必须是当前组件的元素，才会有这个自定义属性，才会被这个样式 作用到
    
    data 是一个函数
        一个组件的 data 选项必须是一个函数 --> 保证每个组件实例，维护 独立 的一份数据对象。
        每次创建新的组件实例，都会新执行一次 data 函数，得到一个新对象。

    组件通信
    组件间通信，就是指 组件与组件 之间 的数据传递
    1. 组件的数据是独立的，无法直接访问其他组件的数据
    2. 想用其他组件的数据 就需要使用  组件通信  技术
    组件间的通信方案
        组件间的关系：父子关系  和  非父子关系
        父子关系：
            props：父 向 子 传递数据
            $emit：子 向 父 传递数据
        非父子关系：
            provide & inject
            eventbus（事件总线）
        通用解决方案：Vuex（适合复杂业务场景）
            
    什么是 prop
        prop 定义：组件上注册的一些 自定义属性
        prop 作用：向子组件传递数据
        特点：
            可以传递 任意数量 的 prop
            可以传递 任意类型 的 prop
    prop 校验
        为组件的 prop 指定 验证要求，不符合要求，控制台 就会有 错误提示，以便于 开发着，快速发现错误
        语法：
            1. 类型校验
                props:{
                    校验的属性名 : 类型 // Number  String  Boolen Array Object ...
                }
            2. 非空校验
            3. 默认值
            4. 自定义校验
                // 完整的 校验语法
                props:{
                    校验的属性名 : {
                        type : 类型,            // Number  String  Boolen Array Object ...
                        required : true,        // 是否必填
                        default : 默认值,        // 默认值
                        validator (value) {     // 自定义校验逻辑
                            return 是否通过校验
                        }
                    }
                }
    
    prop & data 、单项数据流
        共同点：都可以给组件提供数据。
        区别：
            data 的数据 都是自己的，可以 随便改
            prop 的数据 是外部的，不能 直接改，要遵循  单向数据流
        单向数据流：父级 prop 的数据更新，会向下流动，影响子组件。这个数据流动是 单向的。（谁的数据谁负责）
    
    v-model原理
        v-model 本质上是一个 语法糖，例如应用在输入框上，就是 value属性 和 input事件 的合写
        作用：提供 数据的双向绑定
            数据变：视图跟着变 :value
            视图变：数据跟着变 @input
            <template>
                <div id="app">
                    <input v-model="msg" type="text">
                    <input :value="msg" @input="msg=$event.target.value" type="text">
                </div>
            </template>

    表单类组件封装
        1. 表单类组件 封装 --> 实现 子组件 和 父组件数据 的双向绑定
        父传子：数据 应该是父组件 props 传递 过来的，拆解 v-model 绑定数据
        子传父：监听输入，子传父值 给 父组件修改
        <BaseSelect :cityId="selectId" @事件名="selectId=$event">...</BaseSelect>
        <select :value="cityId" @change="handleChange">...</select>
        props:{
            cityId:String
        },
        methods:{
            handleChange(e){
                this.$emit("事件名", e.target.value)
            }
        }

    表单类组件封装 v-model 简化代码
        2. 父组件 v-model简化代码，实现 子组件 和 父组件 数据 双向绑定
        子组件中：props 通过 value 接收，事件触发 input
        父组件中：v-model 给组件直接绑定数据
        <select :value="value" @change="handleChange">...</select>
        props:{
            value : String
        },
        methods:{
            handleChange(e){
                this.$emit('input', e.target.value)
            }
        }

    v-model 的局限性：
        1. 数据名 必须叫 value
        2. 事件名 必须叫 input
        3. 一个标签只能使用一次 v-model
        
    .sync 修饰符 （可以解决 v-model 的局限性）
        作用：可以实现 子组件 与 父组件数据 的 双向绑定，简化代码
        特点：
            prop属性名，可以 自定义，不局限于叫 value。
            事件名，可以 自定义，不局限于叫 input
        
        本质：就是 :属性名  和  @update:属性名  合写

        场景：封装弹框类的基础组件，自定义属性名为visible，用 true表示显示，false表示隐藏
        <BaseDialog : visible.sync="isShow" >
        <BaseDialog : visible="isShow" @update:visible="isShow=$event"
        Props:{
            visible : Boolean
        },
        this.$emit('update:visible', false)

    ref 和 $ref
        作用：利用 ref 和 $ref 可以用于 获取 Dom元素 或 组件实例
        特点：查找范围 --> 当前组件内（更精确稳定）
        获取Dom元素：
            老方法：document.querySelector('input')（查找范围是 整个页面的第一个匹配上的元素）
            新方法：
                1. 目标标签 - 添加 ref 属性
                <div ref="chartRef"> 我是渲染图表容器 </div>
                2. 恰当时机，通过 this.$refs.xxx，获取目标标签
                mounted(){
                    console.log(this.$refs.chartRef)
                }
    Vue 异步更新、$nextTick
        Vue 中的 数据更新  和  视图渲染  任务  是异步的。所以 会导致 数据变化后，需要更新的 Dom元素还没有 渲染出来，
            此时 无法正确的操作到 Dom元素。
        为了 解决这个问题，Vue 提供了 $nextTick() 回调函数，可以在视图更新后 第一时间 运行 设置好的 回调函数，在这
            个时机  进行Dom元素操作 是正常的。

************** Day05 **************
    自定义指令
        基本语法（全局，局部注册）/ 指令的值 / v-loading 指令封装
    插槽
        默认插槽 / 具名插槽 / 作用域插槽
    结合案例：商品列表
        MyTag 组件封装 / MyTable组件封装
    路由入门
        单页应用程序 / 路由 / VueRouter 的基本使用

    需求：当页面加载时，让元素获得焦点
        可以使用 autofocus 属性，（但这个 属性 在 safari 浏览器中有兼容性问题）
        在 mounted() 回调函数中，进行对 dom元素 获取后，再进行  this.$refs.inp.focus()

    自定义指令：将一段 DOM 操作封装到自定义指令中
        自己 定义的指令，可以封装一些 dom 操作，扩展额外功能
        全局注册 - 语法
            Vue.directive('指令名', {
                "inserted"(el){
                    // 可以 对 el 标签，扩展额外功能
                    el.focus()
                }
            })
        局部注册 - 语法
            directives:{
                "指令名":{
                    inserted(){
                        // 可以 对 el 标签，扩展额外功能
                        el.focus()
                    }
                }
            }
    
    指令的值
        需求  实现一个 color 指令 ：传入不同的颜色，给标签设置文字颜色
        语法：在绑定指令时，可以通过 “等号” 的形式 为指令 绑定 具体的参数值
            <div v-color="color"> 测试内容 </div>
            1. 通过 binding.value 可以拿到指令值
            2. 指令值修改  会触发  update函数 执行，可以监听 指令值的变化，进行 Dom元素 更新操作
            directives:{
                color:{
                    inserted(el, binding){
                        el.style.color = binding.value
                    }
                },
                update(el, binding){
                    el.style.color = binding.value
                }
            }
    
    v-loading 指令封装
        场景：实际开发过程中共，发送 请求需要时间，在请求的数据没有回来时，页面会处于空白状态 => 用户体验不好
        需求：封装一个 v-loading指令，实现加载中 播放动图的效果
        分析：
            1. 本质 loading 效果 就是一个 蒙层，盖在盒子上
            2. 数据请i去中，开启loading状态，添加蒙层
            3. 数据请求完毕，关闭loading状态，移除蒙层
        实现：
            1. 准备一个 loading 类，通过伪元素定位，设置宽高，实现蒙层
            2. 开启关闭 loading 状态（添加移除蒙层），本质 只 需要 添加移除类即可
            3. 结合自定义指定的语法进行封装复用
                insertd 中，binding.value 判断指令的值，设置默认状态
                update 中，binding.value 判断指令的值，更新类名状态

    插槽-默认插槽
        作用：让组件内部的一些 结构 支持 自定义
        需求：将需要多次显示的对话框，封装成一个组件
        问题：组件的内容部分，不希望写死，希望能使用的时候 自定义
        语法:
            1. 组件内需要定制的结构部分,改用<slot></slot>占位
            2. 使用组件时，<MyDialog>"{这里填写的内容，将替换子组件中的<slot><slot/>}"</MyDialog> 标签内部，传入结构 替换 slot
    
    插槽-后备插槽（默认值）
        通过插槽 完成了 内容的定制，传什么显示什么，但是如果不传，则是显示空白
        使用 “<slot>这里设置默认值<slot/>” 可以设置默认值

    插槽-具名插槽
        1. slot占位，给 name 属性起名字来区分
        2. template配合 v-slot:插槽名 分发内容
        简化写法：  v-slot:插槽名  =>  #插槽名

    插槽-作用域插槽
        作用域插槽：定义slot插槽的同时，是可以 传值 的。给 插槽 上可以 绑定数据，将来 使用组件时可以用。
        场景：封装表格组件
        1. 父传子，动态渲染表格内容
        2. 利用默认插槽，定制操作列
        3. 删除或查看都需要用到 当前id，属于组件内部数据 通过 作用域插槽 传值绑定，进而使用
        基本使用步骤：
            1. 给 slot 标签，以添加 属性的方式传值
                <slot :id="item.id" msg="测试文本"></slot>
            2. 所有添加的属性，都会被收集到一个对象中
                {id : 3, msg : '测试文本'}
            3. 在 template 中，通过 `#插槽名="obj"`接收，默认插槽名为 default’
                <MyTable :list="list">
                    <template #default="obj>
                        <button @click="del(obj.id)">删除</button>
                    </template>
                </MyTable>

    综合案例-商品列表
        需求说明：
            1. my-tag 标签组件封装
            1.1 双击显示输入框，输入框获取焦点
            1.2 失去焦点，隐藏输入框
            1.3 回显标签信息
            1.4 内容修改，回车 --> 修改标签信息
            2. my-table 表格组件封装
            2.1 动态传递表格数据渲染
            2.2 表头支持用户自定义
            2.3 主体支持用户自定义
        
    单页应用程序
        优点：页面按需更新性能高，开发效率高，用户体验好
        缺点：学习成本高，首屏加载慢，不利于SEO
        应用场景：
            系统类网站 / 内部网站 / 文档类网站 / 移动端站点
        
        页面按需更新：
            前提：明确  访问路径   和  组件  的对应关系
            路由：用来 确定 访问路径 和 组件 的对应关系

        路由器：
            设备 和 ip 映射关系
        Vue中的路由：
            路径  和  组件  的  映射  关系

    VueRouter 的介绍
        目标: 认识 插件 VueRouter，掌握 VueRouter的基本使用步骤
        作用：修改地址栏路径时，切换显示匹配的组件
        说明：Vue官方的一个 路由插件，是一个第三方包
        官网：https://v3.router.vuejs.org/zh/

    VueRouter 的 使用：
        五个 基础 步骤：
        1. 下载：下载 VueRouter 模块到当前工程，版本 3.6.5
            npm i vue-router@3.6.5
            yarn add vue-router@3.6.5
        2. 引入
            import VueRouter from 'vue-router'
        3. 安装注册
            Vue.use(VueRouter)
        4. 创建路由对象
            const router = new VueRouter()
        5. 注入，将路由对象注入到 new Vue 实例中，建立关联
            new Vue({
                render : h(App),
                router
            }).$mount(''#app)
        两个 核心 步骤：
        1. 创建 需要的组件（views目录），配置路由规则
            import Find from './views/Find.vue'
            import My from './views/My.vue'
            import Friend from './views/Friend.vue'
            const router = new VueRouter({
                routes:[
                    //  {  地址栏路径, 组件}
                    {path : '/find', component : Find},
                    {path : '/my', component : My},
                    {path : '/friend', component : Friend}
                ]
            })
        2. 配置导航，配置路由出口（路径匹配的组件显示的位置）
            <div class="footer_wrap">
                <a href="#/find"> 发现音乐 </a>
                <a href="#/my"> 我的音乐 </a>
                <a href="#/friend"> 朋友 </a>
            </div>
            <div class="top">
                <!-- router-view 是 VueRouter插件提供的组件 -->
                <router-view></router-view>
            </div>

    组件存放目录问题（组件分类）
        组件分类：
            .vue文件 分两类：页面组件  和  复用组件
        src/views 文件夹
            主要存放  页面组件 - 页面展示，配置路由使用
        src/components 文件夹
            主要存放  复用组件 - 常用于复用
    路由的封装抽离
        问题：所有的路由配置代码都堆在main.js中不合适
        目标：将路由模块代码 抽离 出来。拆分模块，便于维护
        快速 引入组件：基于 @ 指代 src 目录，从 src 目录触发找组件
        
************** Day06 **************
    声明式导航-导航链接
        需求：实现导航高亮效果
        vue_router 提供了一个全局组件router-link（取代<a></a> 标签）
        1. 能跳转，配置 to 属性 指定路径（必填项），本质还是 <a> 标签，to属性值 无需加 “#”
        2. 能高亮，默认就会提供高亮类名，可以直接设置高亮样式
        <template>
            <div class="footer_wrap">
                <router-link to="/find">发现音乐</router-link>
                <router-link to="/my">我的音乐</router-link>
                <router-link to="/part">朋友</router-link>
            </div>
        </template>
        好处：能跳转，能高亮（自带激活时的类名）

    声明式导航 - 两个类名
        说明：我们发现 router-link 自动给当前导航添加了 两个高亮类名
        <a href="#/my" aria-current="page" class="router-link-exact-active router-link-active"> 我的音乐 </a>
        1. "router-link-exact-active"   : 模糊匹配（用的多）
        2. "router-link-active"         ：精确匹配
        
        自定义 这两个类名的名字（闲这两个类名 名字太长了）
        count router = new VueRouter({
            routes:[...],
            linkActiveClass: "类名1",
            linkExactActiveClass: "类名2",
        })
        <a href="#/my" aria-current="page" class="类名2 类名1"> 我的音乐 </a>

    声明式导航 - 跳转传参
        目标：在跳转  路由  时，进行传值
        1. 查询参数传参     （比较适合 传  多个参数）
            1. 语法格式：
            to="/path?参数名=值&参数名=值"
            2. 对应页面组件接收传递过来的值
            $route.query.参数名

        2. 动态路由传参
            1. 配置动态路由
            const router = new VueRouter({
                routes:[
                    ...,
                    {
                        path: '/search/:words',
                        component: Search
                    }
                ]
            })
            2. 配置导航链接     （比较适合 传 单个参数）
            to="/path/参数值"
            3. 对应页面组件接收传递过来的值
            $route.params.参数名
            4. 如果 不是  必传  参数，可以在 “:words” 后面加 “?”，如 “path: '/search/:words?'”。然后 点击跳转 就不会出现 空白页
    
    Vue路由 - 重定向
        问题：网页打开，url 默认是 “/” 路径，未匹配到组件时，会出现空白
        说明：重定向 --> 匹配path后，强制跳转 path 路径
        语法：{ path:匹配路径, redirect:重定向到的路径}
        const router = new VueRouter({
            routes:[
                {path : '/', redirect : '/home'},
                {path : '/home', component : Home},
                {path : '/search/:words?', compnent : Search}
            ]
        })

    Vue路由 - 404
        作用：当路径找不到匹配时，给个提示页面
        位置：配在路由最后
        语法：path:'*'  （任意路径）- 前面不匹配就命中最后这个
        import NotFind from '@/views/NotFind'
        const router = new VueRouter({
            routes:[
                {path : '/', redirect : '/home'},
                {path : '/home', component : Home},
                {path : '/search/:words?', compnent : Search},
                {path : '*', component : NotFind}
            ]
        })
    
    Vue路由 - 模式设置
        问题：路由的路径 看起来 不自然，有一个 “ # ”。这种 显示模式  可以进行 切换
        1. hash路由（默认）         例如：http://localhost:8080/#/home
        2. history路由（常用）      例如：http://localhost:8080/home  （以后上线需要服务器端支持）

    编程式导航 - 基本跳转
        问题：点击按钮跳转如何实现？
        编程式导航：用 JS 代码来 进行 跳转
        两种语法：
            1. path 路径跳转                （简易方便，用的最多）
                this.$router.push('路由路径')
                this.$router.push({
                    path : '路由路径'
                })
            2. name 命名路由跳转            (适合 path 路径长的场景)
                this.$router.push({
                    name : '路由名'
                })
                然后在 index.js 中编写如下 代码，给 路由规则 命名：
                { name : '路由名', path : '/path/xxx', compnent : XXX}
    
    编程式导航 - 路由传参
        问题：点击搜索按钮，跳转需要如何传参？
        方式：
            查询参数传参
            动态路由传参
        1. path路径 跳转传参
            1.1 query方式传参
            this.$router.push('/路径?参数名1=参数值1&参数名2=参数值2')
            this.$router.push({
                path : '/路径',
                query:{
                    参数名1 : '参数值1',
                    参数名2 : '参数值2'
                }
            })
            1.2 动态路由方式传参
            this.$router.push(`/search/${this.words}`)
        2. name命名 路由传参
            2.1 query方式传参
            this.$router.push({
                name : '路由名字',
                query:{
                    参数名1 : '参数值1',
                    参数名2 : '参数值2'
                }
            })
            2.2 动态路由方式传参
            this.$router.push({
                name : 'search_n',
                params:{
                    words : this.words
                }
            })