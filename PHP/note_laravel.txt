*******************    Day01    ******************
目前大部分的框架公共的特点
1. 单入口，所有的请求必须从 单入口开始，主要是便于管理（统一的参数过滤）
2. MVC的思想
3. ORM 操作数据库（Object Relations Model）：AR模式
注意：Laravel 框架有一个特点，所有 URL 访问都必须事先 定好 路由规则


php版本：7.0.12-nts

composer 方式部署 laravel 项目
    1. 切换 镜像（软件下载地址）为中国内镜像
        镜像官网：https://pkg.phpcomposer.com/
        设置中国镜像源
            composer config -g repo.packagist composer https://packagist.phpcomposer.com
        如果需要解除镜像并恢复到 packagist 官方源，请执行以下命令
            composer config -g --unset repos.packagist
        手动配置 代理  Administrator环境变量 中加入
            http_proxy=127.0.0.1:49938

    2. 创建一个名为 laravel 的 laravel项目
        composer create-project laravel/laravel --prefer-dist ./myprojectname
        composer : composer 程序
        create-project : 创建项目
        laravel/laravel : 需要创建的项目名称
        --prefer-dist : 优先下载压缩包方式，而不是 直接从 GitHub 下载源码（clone方式）
        ./myprojectname : 表示创建的项目在哪个目录

        指定版本方式：
        composer create-project laravel/laravel=5.4.* ./myprojectname --prefer-dist
        composer create-project laravel/laravel=5.4.* --prefer-dist ./myproject02
        composer create-project laravel/laravel=5.8.* --prefer-dist ./myproject04

        更新 composer 程序
            composer self-update



*+++++* 项目 目录结构
    1. app目录：项目的核心目录，主要用于存放 核心代码，也包括控制器、模型
        比如控制器存放如下位置：app/Http/Controllers
        模型文件存放位置，模型文件直接写在 app 目录下即可，但是也可以在该目录下建立其他目录，用于专门存放模型文件，例如
            建立 Admin 目录专门存放后台需要的模型文件
            建立 Home 目录存放前台模型文件目录
        默认的模型文件  app/User.php
    2. bootstrap 目录：laravel 启动目录
        autoload.php 文件用于自动载入需要的类文件
    3. config目录，项目的配置目录，主要存放配置文件，比如数据库的配置
        App.php : 项目主要配置文件
        Auth.php : 用于定义用户认证（登录）的配置文件
        Database.php : 针对数据库的配置
        Filesystems.php : 上传文件、下载文件 存储需要使用到的配置文件
    4. database目录，数据迁移目录
        存储跟数据表相关的操作类文件（迁移文件【创建数据表的类文件】、种子文件【存放一些数据表的数据填充文件】）
    5. public目录：
        项目的入口文件和系统的静态资源目录（css,img,js,uploads）
        后期使用的外部静态文件（js、css、图片等）都需要放到 public 目录下
        注意：当然重点的是项目单一入口文件 也在 这个目录下。因此后续配置虚拟主机的时候需要将站点位置指定到 public 下
    6. resources 目录，存放视图文件，还有就是语言包文件的目录
        lang 目录：语言包目录（如果项目需要本地化 则需要配置语言包）
        views 目录：视图文件存储目录（视图文件也可以分目录管理）
    7. routes目录，是定义路由的目录，web.php 是定义路由的文件
    8. storage 目录，主要是存放缓存文件和日志文件
        注意，如果在 linux 环境下，该目录 需要有可写权限。
        后期 用户 上传文件 如果存在本地 则也在 storage 下
        App：存放用户上传的文件
        Framework: 框架运行时的缓存文件
        Logs: 日志文件
    9. vendor 目录：主要是存放第三方的类库文件
        laravel 思想主要是共同的开发，不要重复造轮子（例如，里面可能存在验证码类，上传类，邮件类），该目录还存放 laravel 框架
        的源码。注意如果要使用 composer 软件管理的，composer 下载的类库 都是存放在 该目录下
    
    10. .env 文件：主要设置一些系统相关环境配置文件信息。
            config 目录里面的文件配置内容，一般都是读取该文件里面的配置信息（config里面的配置项的值基本都是来自 .env 文件）
    11. artisan 脚手架文件，主要用于生成代码的（自动生成）
            比如生成器，模型文件等。
            执行命令：php artisan 需要执行的指令
                要求1：php 必须添加环境变量，保证版本正确
                要求2：artisan 必须存在命令行当前的工作路径下
    12. composer.json 依赖包 配置文件
            声明当前需要的软件依赖，但是不能删除，composer 需要使用
    
    重点掌握的目录（频繁使用）
    目录下                          作用
    app                             保存模型文件（默认）
    app/Http/Controllers            保存控制器文件
    resources/views                 保存视图文件
    config                          配置文件目录
    routes                          存放路由文件
    database/migrations             存放数据库迁移文件（操作数据表结构）
    database/seeds                  存放数据库种子文件（模拟测试数据）

*+++++* 启动方式
    1. 指令方式启动：
        命令：php artisan serve
        不推荐使用该方式 启动
        1. 能够运行 php 代码，但是不能启动数据库
        2. 该方式启动后，如果修改了项目的配置 .env 的话，则需要重新启动才会生效
    2. 使用 wamp 或 lamp 环境
        1. 虚拟主机配置：
            修改 apache 的虚拟主机 vhost 的配置文件
            vhost文件位置：I:/serv/2017-06-13/Apache/conf/extra/httpd-vhosts.conf
            <VirtualHost *:80>
                # 配置站点管理员的邮箱，当站点产生 500 错误的时候，会显示在页面上
                ServerAdmin yiyiyi@outlook.com
                # 站点的根目录
                DocumentRoot "E:\GitRepository\VueBackManSystem\PHP\Day01\myprojectname\public"
                # 站点需要绑定的域名
                ServerName www.0223.com
                # 服务器的别名的域名
                ServerAlias 0223.com
                # 针对站点的详细的配置
                <Directory "E:\GitRepository\VueBackManSystem\PHP\Day01\myprojectname\public">
                    allow from all
                    AllowOverride all
                    Options +indexes
                </Directory>
            </VirtualHost>

        2. 修改 host文件（线上叫 DNS 域名解析）
            host文件位置：C:\Windows\System32\drivers\etc\hosts
            “127.0.0.1 www.0223.com 0223.com”
        
        3. 重启 apache

*+++++* laravel 入门使用（路由）
    什么是路由：将用户的请求按照事先规划的方案提交给指定的控制器或者功能函数来进行处理【通俗的讲，路由就是访问地址形式】
    在 ThinkPHP框架中，当我们在 URL 地址中，传递 m、c、a 三个参数时，系统会自动跳转到指定模型中 指定 控制器 的 指定方法
    这些处理过程都是由框架自动完成的。但是，在 laravel 框架中，其并没有指定固定参数，其路由必须要手工进行配置
    1. 路由配置文件
        路由文件的位置：routes/web.php 文件
    2. routes\web.php 配置文件中配置路由
        2.1. 默认根路由
            问题：为什么当我们在浏览器中访问虚拟域名 http://域名 时如何显示 Laravel5 ？
            答：主要是收到 web.php 路由的影响，当我们访问 http://域名 时，系统会自动跳转到 web.php路由，然后查看
                是否由定位到根目录下的 get 请求，找到如下代码
                // 默认根路由，当系统创建好之后就存在的
                Route::get('/', function(){
                    return view('welcome'); // view 方法，输出视图文件，相当于 $this->display()
                })
        2.2. 路由定义格式：
            Route::请求方式（'请求的URL'，匿名函数或控制响应的方法）
              比如请求域名下根目录
                Route::get('/',function(){return 'hello world'})
                函数的返回值，就是请求的响应
                // 默认根路由，当系统创建好之后就存在的
                Route::get('/', function(){
                    //return view('welcome'); // view 方法，输出视图文件，相当于 $this->display()
                    return 'hello world.';
                })
              又比如请求：http://域名/home 地址，则 路由 写成
                Route::get('/home', function(){return '您当前访问的是 /home 地址';})
                // 定义访问 /home 的路由
                Route::get('/home', function(){
                    // 输出内容
                    return '您当前访问的是 /home 地址';
                })

            ****** 注意 ******
                问题：
                    路由不起作用，只有根路由起作用，自定义路由不起作用？？
                解决：
                    1. 如果使用 nginx 则 在 文件 D:\phpstudy_pro\Extensions\Nginx1.15.11\conf\vhosts\0localhost_80.conf 中， 添加 以下配置 
                        location / {
                            try_files $uri $uri/ /index.php?$query_string;
                        }
                    2. 如果使用 apache 则 在 文件 E:\GitRepository\VueBackManSystem\PHP\Day01\myproject04\public\.htaccess 中 添加以下配置
                        <IfModule mod_rewrite.c>
                            RewriteEngine On
                            RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
                            RewriteBase /
                            RewriteRule ^index\.php$ - [L]
                            RewriteCond %{REQUEST_FILENAME} !-f
                            RewriteCond %{REQUEST_FILENAME} !-d
                            RewriteRule . /index.php [L]
                        </IfModule>
                原因：
                    使用 phpstudy_pro 默认的配置，应请求 /login , nginx 会尝试查看是否有一个名为 /var/www/html/myproject/public/login 的文件存在，那么如果一个名为 /var/www/html/myproject/public/login/ 的文件夹如果它们都不存在，则返回错误 404。
                    这不是您所期望的，因为您没有创建名为 login 的文件。 ，你刚刚在 Laravel 的路由器中创建了一个路由。因此，您必须以调用 index.php 的方式配置 nginx。每次向该虚拟主机请求时，公共(public)目录的文件，然后框架将能够将请求所针对的 URL 与您注册的路由进行比较。
                    您应该编辑您的配置以添加以下位置 block ，以便将所有请求(静态资源的请求除外)重定向到 index.php ，以原始查询为参数:
                    location / {
                        try_files $uri $uri/ /index.php?$query_string;
                    }

        2.3. 请求方式
            有效的路由方法
            我们可以注册路由来响应任何 HTTP请求：
                Route::get($url, $callback());
                Route::post($url, $callback());
                Route::put($url, $callback());
                Route::patch($url, $callback());
                Route::delete($url, $callback());
                Route::options($url, $callback());
            有时候还需要注册路由响应多个HTTP请求————这个可以通过 match 方法来实现，或者用 any 方法 注册一个路由来响应所有 HTTP请求：
                Route::match(['get', 'post'], function(){
                    //
                });
                Route::any('foo', function(){
                    //
                });
            常用的记住 四个 ：get/post/match/any
                Get : 表示支持 get 请求的路由
                Post : 表示支持 post 请求的路由
                Match : 表示匹配固定（自己定义）的请求方式的路由
                Any : 表示匹配任意请求方式的路由

                语法上 match 比 get/post/any 多一个参数
                Route::match(匹配的请求类型, 地址, 回调);
                匹配请求类型要求是数组格式的声明（建议使用短数组）
                // 使用 any 方式请求
                Route::any('/any', function(){
                    return 'any类型的请求';
                })
                // match 类型
                Route::match(['get', 'post'], '/match', function(){
                    return 'match类型的请求';
                })
    3. 路由参数
        路由参数其实就是给路由传递参数
        参数分为 必选参数 和 可选参数
            Route::get('/user/{id}', function($id){
                return "当前用户id是：".$id;
            });
            Route::get('user2/{id?}', function($id = null){
                return "当前用户id是：".$id;
            })
            补充：除了通过定义路由的方式来传递路由参数以外，还可以通过 “ ？” 形式传递参数，
                例如：http://www.0223.com/user?id=11111
                这种写法不需要将参数部分写进路由文件 web.php 中。
    4. 路由别名
        路由别名相当于在路由定义的时候，为路由起了一个别名，在以后的程序中可以通过这个别名来获取路由的信息
        例如：已有路由
            Route::get('/user/{id}', function(){
                reutrn "当前用户id是：".$id;
            })->name('名字')
            Route::any('/test5', function(){
                reutrn "当前用户id是：".$_GET['id'];
            })->name('名字')
            则 调用有名字的 路由 可以写成：route('名字')

            查看系统已经 存在的 路由
                命令：php artisan route:list
    
    5. 路由群组（理解）
        比如 后台 有 如下路由
        /admin/login
        /admin/logout
        /amdin/index
        /admin/user/add
        /admin/user/del
        ...
        他们的共同点是，都有一个 “/admin/” 前缀，为了管理方便，可以把他们放到一个路由分组中。
        使用 prefix 属性指定 路由前缀
        比如，为所有路由 URIs 前添加前缀 “admin”
            Route::group(['prefix'=>'admin'], function(){
                Route::get('users', function(){
                    return  "当前访问的是： /admin/users";
                });
            });
            语法：Route::group(公共属性数组, 回调函数)

*+++++* 控制器使用
1. 控制器文件写在哪里
    位置: app/Http/Controllers

2. 控制器文件如何命名
    依照 已经 存在的 四个规范 控制器文件名 可以得知其命名方式
    大驼峰的控制器名+Controller.php

3. 结构代码如何书写
    注意：其控制器基础结构代码，不需要手动编写，可以通过 artisan 命令行来自动生成，生成的文件默认在  app/Http/Controllers 目录中
    命令：php artisan make:controller 大驼峰的控制器名+Controller.php
    命令使用位置：当前项目的根目录下（app 或 public 目录的上级目录）
        例如：php artisan make:controller TestController
            如果需要指令生成在 app/Http/Controllers/TestDir01/TestDir02 目录下，则使用
                php artisan make:controller TestDir01/TestDir02/TestController

4. 控制器路由
    即，如何使用路由规则调用控制器下的方法，而不再 走 回调函数
    路由设置格式基本相同，只是将你能函数换成‘控制器类名@方法名’
    定义格式如下：
        Route::请求方法('路由表达式', '控制器@方法')

        例如 在 Test控制器中创建 test1 方法，其中输出 phpinfo 信息：
        class TestController extends Controller {
            // phpinfo 信息：
            public function test1(){
                return phpinfo();
            }
        }
        在 routes\web.php 文件中 加入：
        Route::get('/home/test/test1', 'TestController@test1');

5. 控制器是否可以分目录管理（支持）
    例如：需要创建前台分组 Home，在前台平台中创建 Home/indexController.php 文件，同时建立后台的分组 Admin，再创建后台的 Admin/indexController.php
        php artisan make:controller Admin/IndexController 
        php artisan make:controller Home/IndexController 
    
    routes/web.php 中加入
        Route::get('/home/index/index', 'Home\IndexController@index');
        Route::get('/admin/index/index', 'Admin\IndexController@index');

6. 接收用户输入
    接收用户输入的类：Illuminate\Support\Facades\Input
    Facades：门面的思想。门面是介于一个类的实例化与没有实例化中间的一个状态。其实是类的一个接口实现。这个
        状态下可以不实例化类，但是可以用类中的方法。
    Input::get('参数名字', '如果参数没有被传递使用该默认值')
    Input::all()  获取所有的用户输入
    Input::get('')  获取单个的用户输入
    Input::only([])  获取指定的几个用户输入
    Input::except([])  获取指定几个用户的输入以外的所有的参数
    Input::has('name')  判断某个输入的参数是否存在

    上述方法即可以获取 get 中的信息，亦可以获取 post 中信息

    导入的类的路径太长时，可以设置 别名。在 config/app.php 文件中 找到 “aliases” 配置项 最后，
        添加一行：'Input' => Illuminate\Support\Facades\Input::class,
        后续 再使用 时，就直接 写 ： use Input
    
    编写路由测试：
        在 laravel 中友好输出函数：dd()
        作用是 dump + die，后续的代码不会执行
        routes/web.php 中加入
            Route::get('/home/test/test2', 'TestController@test2');
        用户输入测试 地址：http://localhost/home/test/test2?id=235234&name=haha&age=34&gender=1
            // 获取一个值，可以加 缺省参数
            echo Input::get('id', '10086').'<br>';
            // 获取全部的值（数组的形式返回）
            $all = Input::all();
            var_dump($all);
            // dd($all); // dump + die
            // 获取指定 的信息（字符串形式）
            dd(Input::get('name'));
            // 获取指定的几个值（数组形式）
            dd(Input::only(['id', 'age']));
            // 获取 除了 指定值 之外的所有值（数组形式）
            dd(Input::except(['id', 'name']));
            // 判断 某个值  是否存在
            dd(Input::has('gender'));
        提示：在 laravel 中，不仅仅是 Input 门面 可以获取 用户的输入，Request门面 也可以获取用户输入
            他的语法和 Input 一样，也存在 get , all , only 等方法

*+++++* DB类操作数据库（重点）
    按照MVC的架构，对数据的操作应该放在 Model 中完成，但如果不适用 Model，我们也可以使用 Laravel框架提供的 DB 类操作数据库，
    而且，对于某些极其复杂的 sql，用 Model 已经很难 完成，需要开发者 自己手写 sql 语句，使用 DB 类去执行 原生 sql。laravel 中
    DB 类的基本使用方法 DB::table('tablename')，获取操作 tablename 表的实例
1. 数据表的创建于配置
    数据库字符集 使用 utf8 和 utf8-genarer-cli （utf8mb4 包含 utf8）
    1. 创建数据库 和 测试表
    create table member(
        id int primary key auto_increment,
        name varchar(32) not null,
        age tinyint unsigned not null,
        email varchar(32) not null
    ) engine myisam charset utf8;

    2. 方法 1：
        数据库在 laravel 框架中 配置（配置文件：.env 文件中）
        DB_CONNECTION=mysql
        DB_HOST=localhost
        DB_PORT=3306
        DB_DATABASE=myproject04db
        DB_USERNAME=root
        DB_PASSWORD=123456
       方法 2:
        也可以在 config 目录下的 database.php 文件里面的 mysql配置模块 配置，使用 env() 函数，表示先从 .env 文件中获取，如果获取成
        功则使用，如果获取失败，则使用 env() 函数的 第二个参数
       注意：
        database.php 的 mysql配置模块有个 strict=>true 严格模式属性，建议关闭
        如果 是 php artisan serve 方式启动的，修改了配置文件。则需要重新启动，才能读取修改后的配置文件。如果是 wamp/lamp 等环境则 无需 重启
    
    3. 在 Test 控制器中 引入 DB 门面
        DB 门面 在 app.php 中已经定义了别名 DB，可以直接使用 use DB

    4. 定义 增删改查 需要的路由
        // Route::get('/home/test/add', 'TestController@test2');
        // Route::get('/home/test/del', 'TestController@test2');
        // Route::get('/home/test/update', 'TestController@test2');
        // Route::get('/home/test/select', 'TestController@test2');
        Route::group(['prefix' => '/home/test'], function(){
            Route::get('/add', 'TestController@add');
            Route::get('/del', 'TestController@del');
            Route::get('/update', 'TestController@update');
            Route::get('/select', 'TestController@select');
        });

2. 增加信息
    对数据库中的某个表增加数据主要使用：insert()  和 insertGetId()
    insert(一维数组 或 多维数组)：可以同时添加 一条 或 多条，返回值是 布尔类型
    insertGetId(一维数组)：只能添加一条数据，返回自增 ID
    注意：
        // 指定需要操作的数据表实例
        $db = DB::table('member');
    向 member 表同时添加多条数据
        // 增加多条数据（如果单个则参数 是一维数组，多个则是 多维数组）
        $rst1 = $db->insert([
            [   'name'  => '张三', 'age'   => '23', 'email' => 'zhangsan@itcast.cn' ],
            [   'name'  => '李四', 'age'   => '24', 'email' => 'lisi@itcast.cn' ],
            [   'name'  => '王五', 'age'   => '25', 'email' => 'wangwu@itcast.cn' ]
        ]);
    向 member 表 添加 一条数据
        // 增加 一条数据
        $rst1 = $db->insertGetId([
            'name'  => '王五', 'age'   => '25', 'email' => 'wangwu@itcast.cn'
        ]);

3. 修改数据
    数据修改可以使用 update()、increment()、decrement() 函数来实现
    update() 可以修改整个记录中的全部极端
    increment()、decrement() 表示修改 数字字段 的数值（递增 或 递减），如记录 登录次数 等
    案例：
        ->where()->update()
        where 语法：（如果第二个参数运算符 是 “=”，则 “=” 可以省略不写，如：-> where(字段, 值)）
            -> where(字段, 运算符, 值)
        实际案例 1：
            //  把 id>3 的名称，修改为 '王二小'
            public function edit(){
                $db = DB::table('tablename');
                // 把 id=1 的名称，修改为 '王二小'
                $rst = $db -> where('id', '>', '3') -> update([
                    'name' => '王二小'
                ]);
                dd($rst);
            }

        实际案例 2：
            public function edit(){
                $db = DB::table('tablename');
                // 把 id > 3 的对应的 年龄 加 10
                $rst = $db -> where('id', '>', '3') -> update('age', 10);
                // 把 id < 3 的对应的 年龄 减 5
                $rst = $db -> where('id', '<', '3') -> update('age', 5);
                dd($rst);
            }
        
        返回的结果  $rst 是数据库中 真实 修改了  多上条 记录的 条数

4. 查询数据
    4.1 取出基本数据
        案例 1：
            获取 member 表中 所有的数据
                DB::table('member')->get(); // 相当于 select * from member;
            返回值 是一个 集合对象:
                Illuminate\Support\Collection {#232 ▼
                #items: array:3 [▼
                    0 => {#234 ▼
                    +"id": 1
                    +"name": "张三"
                    +"age": 18
                    +"email": "zhangsan@itcast.cn"
                    }
                    1 => {#236 ▼
                    +"id": 2
                    +"name": "李四"
                    +"age": 19
                    +"email": "lisi@itcast.cn"
                    }
                    2 => {#237 ▼
                    +"id": 3
                    +"name": "王五"
                    +"age": 25
                    +"email": "wangwu@itcast.cn"
                    }
                ]
                }
        案例 2：
            获取 id<3 的数据
                $data = $db -> where('id', '<', '3') -> get();
            注意：where 方法之后 继续调用 where 方法：
                ->where()->where()->where()         语法的查询条件 是  且 &&
                ->where()->orWhere()->orWhere()     语法的查询条件 是  或 ||
                orWhere() 函数的 参数 和 where() 一致

        Get() 查询的结果每一行 的记录是 对象的形式，不是数组。

    4.2 取出单行数据
        DB::table('member')->first(); //返回值是一个 对象
        等价于 limit 1

    4.3 获取某个具体的值
        DB::table('member')->where('id','1')->value('name');
        
    4.4 获取某些字段数据
        $user = DB::table('member')->select('name','email')->get();
        $user = DB::table('member')->select('name as user_name')->get();

    4.5 排序操作
        DB::table('member')->orderBy('age','asc')->get();  // asc  升序
        DB::table('member')->orderBy('age','desc')->get(); // desc 降序

    4.6 分页操作（限制输出记录数）
        DB::table('member')->offset(2)->limit(3)->get();    // 从 get() 获取的集合中 从 第2条 数据后的   第 3 条 到 第 6 条，共 3 条数据
        limit：表示 限制输出的条数
        offset：从什么地方开始

5. 删除数据（delete）
    删除分两种： 物理删除  和  逻辑删除
    数据删除可以通过 delete()函数 和 truncate()函数 来实现
    Delete() 表示删除记录
        DB::table('member')->where('id','1')->delete();
        返回的结果  $rst 是数据库中 真实 修改了  多上条 记录的 条数
    Truncate() 表示清空整个数据表
        DB::table('member')->truncate();
        返回的结果  $rst 是 null

6. 执行任意的SQL语句
    1. 执行任意的 insert update delete 语句【影响记录的语句使用 statement 语法】
        DB::statement("insert into member values(null,'')");
    2. 执行任意的 select 语句【不影响记录的语句使用 select 语法】
        $rst = DB::select("select * from member");

*******************    Day02    ******************
*+++++* 视图操作【重点】
1. 视图写在哪里
    位置：resources/views
    可以进行分目录管理

2. 视图文件的命名与渲染
    (1) 文件名 习惯 小写
    (2) 文件名的后缀是 .blade.php（因为 laravel 里有一套模板引擎 就是 使用 blade，可以直接使用标签语法 {{$title}}，也可以使用原生 php 语法显示数据
    (3) 需要注意的是也可以使用 .php 结尾，但是这样的话就不能使用 laravel 提供的标签 {{$title}} 语法显示数据，只能用原生语法 <?php echo $title; ?> 显示数据
    两个视图文件可以同时存在，则 .blade.php 后缀的优先显示出来
    案例：
        编写一路由地址，调用控制器的 test3() 方法，展示视图 test3文件（创建 2 个，一个 .blade.php 结尾，另一个 .php 结尾）
        新增路由：
            Route::get('/home/test/test3', 'TestController@test3');
        展示 视图的方法：
            return view('视图文件名称');
            视图可以进行 分目录管理的，如 home/test/test3 视图，可以 写成
                return view('home/test/test3');   或者 
                return view('home.test.test3');

3. 变量分配与展示
    控制器 和 视图  要进行 数据 交互
    语法：
        1. view(模板文件名称, 数组)         // 这个 “数组”，就是我们需要 分配的变量 键值对 集合
        2. view(模板文件名称)->with(数组)
        3. view(模板文件名称)->with(名称, 值)->with(名称, 值)
        使用 view() 方式 渲染 一个视图后，在 .blade.php 的视图文件中，模板中输出变量使用 “{{$变量}}”
            $date = date('Y-m-d H:i:s', time());
            $day = '星期二';
            return view('home.test.test3', ['date'=>$date, 'day'=>$day]);
        在视图 test3.blade.php 文件中 展示 传递的变量
            现在是时间是:{{$date}}，今天是 {{$day}}

4. 扩展：compact() 函数的使用（传参）
    compact() 函数，是 php 内置函数 跟 laravel 框架没有关系。作用主要是用于打包数组的。
    语法：compact('变量名1', '变量名2', '变量名3', ...)
    改写上面的代码：
        $date = date('Y-m-d H:i:s', time());
        $day = '星期二';
        return view('home.test.test3', compact('date', 'day'));

5. 模板中直接使用函数
    回顾：在 smarty 模板引擎中存在一个特殊的符号 “|”（管道），名称 称之为 变量修饰符。作用就是在 视图中 解释变量（使用函数去处理变量）
    在 laravel 中，视图调用函数 其语法 基本 与 js、php 的语法一致，只不过要求 左右包含 大括号。
    语法：{{ 函数名(参数1, 参数2, ...) }}
    说明：函数名 可以是 php 内置的，也可以是 laravel 框架中定义的
    案例：
        在数据库中一般存储时间都是以时间戳 去储存的，但是在页面上展示的时候 不合适。就需要 对其格式化处理。
        需要在 视图中 对其格式化 则怎么写？
            一年后的时间是：{{ $time }} 格式化后：{{ date('Y-m-d H:i:s', $time)}}

        如果需要使用更多的函数，则需要遵循函数的语法格式即可

6. 循环与分支语法标签【重点】
    // 在视图里面遍历数据【重点】
    在 laravel 中模板中 循环输出数据，则需要 遵循 语法：
        // php写法
        foreach ($varialbe as $key => $value){
            // 循环体
        }

        // laravel 中 视图中 写法
        @foreach ($varialbe as $key => $value)
            // 循环体
        @ endforeach
    案例：
        使用循环标签的语法，在视图中输出数据
        新增路由：
            Route::get('/home/test/test4', 'TestController@test4');
        创建需要的方法，获取一些数据，传递给视图
            // 循环标签
            public function test4(){
                // 查询数据
                $data = DB::table('member')->get();
                // 展示视图，传递数据
                return view('home.test.test4', compact('data'));
            }
        创建 需要的 视图文件
            home/test/test4.blade.php，文件中加入 以下 代码
                @foreach ($data as $key => $value)
                    {{$value->id}}&emsp;&emsp;{{$value->name}}&emsp;&emsp;{{$value->age}}&emsp;&emsp;{{$value->email}}<br>
                @endforeach
        在此过程中需要注意的就是 get 查询到的结果 集中每一条记录 其实都是一个对象。
        因此在循环具体字段的时候需要注意使用 对象调用属性 的方式 才可以 获取其数据。

    // 在视图里面可以执行 if 判断【重点】
    if 语法在模板引擎中的写法：
        // php 中写法
        if (条件判断) { }
        elseif (条件判断) { }
        else { }

        // laravel 中 视图中 写法
        @if (条件判断) { }
        @elseif (条件判断) { }
        @else { }
        @endif

    案例：
        要求在 php 代码中（控制器的方法）动态输出 今天的 星期几 的 数字（1~7），将数字传递给视图。显示出今天是 星期几。如果是 7
        则在页面中输出 “星期天”【将数字转化成汉字】

7. 模板 继承 / 包含  1.01.30
    继承 不仅仅在 php 类中存在，在视图中同样存在。一般是用于做 有公共部分的页面
    案例：
        编写父级页面，再编写一个子页面（相当于php中的 2 个类）
            编写父级页面：
                语法： @yield('名字')       在父级页面中的占位
        继承语法：
            字模板中按以下语法书写：
                @extends('需要继承的模板文件名')
                如：
                    @extends('home.test.parent')
            通过 section 标签 绑定区块/部件 到父级页面，区块 名称 就是 父级页面 yield 标签的 参数名。
                @section(区块名称)
                代码
                @endsection
                如
                    @section('mainbody')
                    <div>
                        科阿斯兰的放假啦空手道解放考虑按实际开来
                    </div>
                    @endsection

    包含
        语法：@include('模板文件名')                文件名不含后缀，语法类似 view 方法参数
        如：
            <h1>BBBB</h1>
            @include('home.test.test4')
            <h1>CCCC</h1>
            @include('home.test.parent')
            <h1>DDDD</h1>

8. 外部静态 文件 引入方式（了解）
    在写页面肯定会 引入相关的外部文件（js、css、image），则会设计到 路径的问题。
    以下面这个 app.css 为例，看如何去引入 css 文件
        以往的方式：
            <link rel="stylesheet" type="text/css" href="/css/app.css">
        laravel 视图文件中 的方式
            <link rel="stylesheet" type="text/css" href="{{asset('css')}}/app.css">
    Asset 方法中的参数可以是 多级目录 也可以是 单击目录。
        <link rel="stylesheet" type="text/css" href="{{asset('css/abc/def')}}/app.css">

*+++++* CSRF攻击
1. 什么是 CSRF 攻击
    CSRF 是 跨网站请求伪造（Cross-Site request forgery）的英文缩写
    Laravel 框架中避免 CSRF 攻击，很简单：Laravel 自动为 每个用户 Session 生成了一个 CSRF Token。
    该 Token 可用于验证登录用户 和 发起请求者是否是 同一个人，如果不是 则请求失败。【该原理和 验证码 原理一致】
    Laravel 提供了一个全局帮助函数 csrf_token 来获取该 Token 值，
    因此 只需要在视图提交表单中 添加 如下 HTML 代码，即可 在请求中 带上 Token：
        <input type="hidden" name="_token" value="<?php echo csrf_token(); ?>
                  
2. laravel中 如何避免 CSRF 攻击
    创建 路由 
        // csrf 验证
        Route::get('/home/test/test6', 'TestController@test6');
        Route::post('/home/test/test7', 'TestController@test7');
    创建 控制器 的方法
    // 展示 基础的 表单
        public function test6(){
            // 
            return view('home.test.test6', compact('data', 'day'));
        }
        // 处理请求
        public function test7(){
            return '请求提交成功';
        }
    创建需要的简易表单
        <form action="{{route('test7')}}" method="post">
            姓名：<input type="text" name="name" value="" placeholder="请输入姓名"><input type="submit" value="提交">
        </from>

    结论：通过刚才的案例，说明在 laravel 中 csrf 验证机制默认是开启的

    解决 报错问题（如何通过 csrf 验证）
        带上 csrf 需要的 token 值。随着 请求传递给 后续的方法
        <input type="hidden" name="_token" value="{{csrf_token()}}">
    
    针对 csrf_token() 方法 的 简化：
        {{ csrf_field()}}
        等价于  “<input type="hidden" name="_token" value="{{csrf_token()}}">”
    两者的区别
        csrf_token 只是 输出 token 的值
        csrf_field 输出了 一个 整个 input 隐藏域
        当使用 异步提交表单的 方式 时：必须使用 csrf_token()
            如：$.get(rul, {{_token}});
        
3. 从 CSRF 验证中 排除 例外路由
    并不是 所有请求都需要 避免 CSRF 攻击，比如去 第三方 API 获取数据的 请求。
    可以通过在 VerifyCsrfToken.php（app\Http\Middleware\VerifyCsrfToken.php）文件中，将要排除 请求 URL 添加到 $except 属性数组中。

    如果 需要 排除 全部 路由 使用 csrf 的话，使用 “” 通配符，加入到 $except 属性数组中。
        protected $except = [
            // 这里 添加 需要 排除 csrf 验证的 路由
            '*'
        ];

*+++++* 模型操作（AR模式）【理解】
    Laravel 自带的 Eloquent ORM 提供了一个美观、简单的数据库打交道的 ActiveRecord 实现，每张数据表 都对应一个与该表进行交互的“model模型”，
    模型 允许你 在表中进行数据查询，以及 插入、更新、删除 等操作
    AR模式三个核心（映射）：
        每个数据表              与数据进行交互的 model 模型映射（实例化模型）
        记录中的字段            与模型类的属性映射（给属性赋值）
        表中的每个记录          与一个完整的请求实例映射（具体的CURD操作）

1. 定义模型
    定义模型的位置：默认 在 app 目录下，建议使用  分目录管理
    命名规则：
        本身 laravel 对模型的命名没有严格的要求，一般采用 表名（首字母大写）.php 。比如：Member.php User.php Goods.php
    创建模型
        可以使用 artisan 命令
        php artisan make:model Member
    定义模型的注意事项：【重点】
      （必做 protected）  第一：定义一个 $table 属性，值是不要前缀的表名，如果不指定则使用 类名的 复数形式作为 表名。
                    如果 模型为 Member，模型在不指定 table 属性时，默认会去找 Members 表名。
      （可选 protected）  第二：定义 $primaryKey 属性，值是 主键名称，如果需要使用 AR 模式的方法，则需要指定主键（Model::find(n)）
                    在主键 字段 不是 id 的时候，则需要 指定 主键
      （可选 public   ）  第三：定义 $timestamps 属性，值是 false，如果不设置为 false，则 默认会操作表中 created_at 和 update_at 字段。
                    我们表中一般没有这 两个 字段，所以设置为 false，表示不要操作 这两个字段
      （可选 protected）  第四：定义 $fillable 属性，表示使用 模型插入数据时，允许插入到数据库的字段信息。
    注意：
        使用模型中 create 插入数据时，要设置 $fillable 允许 入库的 字段。使用 $guarded 是设置 排除 入库的 字段
            //定义 模型关联的数据表（一个模型 只操作  一个表）
            protected $table = 'member';
            //定义 主键（可选）
            protected $primaryKey = 'id';
            //定义 禁止操作 时间
            public $timestamps = false;
            //设置 允许写入的 数据字段
            protected $fillable = ['id', 'name', 'age', 'email'];

2. 模型控制器中调用
    引入模型类：
        use App\Home\Member;
        模型的使用，在控制器中 的 使用方式 有 2 种：
            1. 直接像 使用 DB门面 一样的操作方式：以调用静态方法为主的形式，该形式下模型不需要实例化
                如：Member::get()    DB::table('member')->get()
            2. 实例化模型然后 再去使用模型类（普通）
                如：$model=new Member();  $model->get();

3. 定义测试路由
    // 模型的增删改查
    Route::post('/home/test/test8', 'TestController@test8');
    Route::get('/home/test/test9', 'TestController@test9');
    Route::get('/home/test/test10', 'TestController@test10');
    Route::get('/home/test/test11', 'TestController@test11');

    Route::get('/home/test/test12', 'TestController@test12');

4. 基本操作
    1. 添加数据
        在 laravel 里面完成数据的添加 可以使用 两种 方式：
        方式一：（AR模式）：使用 AR 模式必须要实例化模型
        注意：
            在 Laravel 里面添加数据的时候，需要先实例化模型，然后为模型设置属性，最后调用 save 方法即可。
            $member = new Member();         // 映射 关系 1：将表 映射到 模型
            $member->name = value;          // 映射 关系 2：将字段映射到属性，属性名 和 字段名 一致
            $member->save();                // 映射 关系 3：将记录映射到实例
        如：
            public function test8(){
                // 实例化 模型，将 表 和 属性 映射 起来
                $model = new Member();
                // 给属性赋值，将字段 与 类的 属性 映射起来
                $model -> name = '李逵';
                $model -> age = '34';
                $model -> email = 'likui@afs.com';
                $res = $model -> save();
                dd($res);
            }
        
        上面的 这种方法可以完成 数据的插入，但是 不建议使用。

        方式二：
        先建立个建议的表单
            <form action="/home/test/test8" method="post">
                <p>姓名：<input type="text" name="name" value=""></p>
                <p>年龄：<input type="text" name="age" value=""></p>
                <p>邮箱：<input type="email" name="email" value=""></p>
                {{ csrf_field() }}
                <input type="submit" value="提交">
            </from>
        首先，在控制器文件引入 Request 这个类
            use Illuminate\Http\Request;
            Request 类使用：(与前面的 input 门面 类似，Input调用的是静态方法 获取路由地址上传的参数)
                对象 传递
                request 语法
                $request->all()
                $request->input('name')
                $request->only(['name', 'id'])
                $request->except(['name', 'gender'])
                $request->has('name')
                $request->get('name')
            添加操作代码语法如下：
                静态调用：Member::create($request->all()) //返回值 是一个对象
                实例调用：$model->create($request->all()) //返回值 是一个对象
        注意：
            如果使用 create方法，则需要在模型中定义 fillable 属性，允许写入字段的定义，如果没有时间相关字段也需要禁用时间自动更新功能
                // 禁用时间自动更新功能
                public $timestamps = false;
                // 使用 create方法，则需要在模型中定义 fillable 属性，允许写入字段的定义
                protected $fillable = ['id', 'name', 'age', 'email'];
        public function test8(Request $request){
            // 实例化 模型，将 表 和 属性 映射 起来
            $model = new Member();
            $inputData = $request->all(); // 直接从 表单上 获取所有 输入信息，返回一个 数组
            $res = $model->create($inputData);
            dd($res);
        }

    2. 查询操作
        获取指定主键的一条数据
            $info = Member::find(4); // 静态方法调用，获取主键 为 4 的数据
            public function test9(){
                $data = Member::find(4);
                dd($data->name);
                dd($data);
            }
            其 结果集 默认是 一个对象
            如果需要在 laravel中 对象的结果集 转化为数组，则需要在最终添加方法的调用：
                ->get()->toArray();
                例如：$data = Member::find(4);

        获取符合指定条件的 第一 条数据
            Member::where('id', '>', 4)->first()
            如：
            public function test9(){
                // $data = Member::find(4);
                // dd($data->name);
                $data = Member::where('id', '>', 7)->first();
                dd($data->toArray());
            }
        
        查询多行　并且　指定字段
            Member::all()
            Member::all([字段1, 字段2])         // 与 get 方法的区别，all 不支持连接其他的辅助查询方法
            相当于 get 方法
            Member::get()
            Member::get([字段1, 字段2])

            按条件查询指定多个字段
            Member::where('id', '>', 2)->get(['列1', '列2'])        // 数组选列
            Member::where('id', '>', 2)->select('列1', '列2')->get()        // 字符串选列
            Member::where('id', '>', 2)->select(['列1', '列2'])->get()        // 字符串选列
            
    3. 修改数据
        注意：在 laravel 里面 如果需要更新数据（ORM模型方式），需要先调用模型的 find 方法 获取对应的记录，返回一
        个模型对象，然后为该模型对象 设置要更新的数据（对象属性），最后调用 save() 方法即可。
        例如：
            $user = User::find($id);
            $user->title = $_POST['title'];
            $user->content = $_POST['content'];
            return $user->save() ? 'OK' : 'Faild';
        案例：
            实现 ORM形式 模型的修改操作。修改 id=6 的用户的 邮箱为：ssss@aaa
                public function test10(){
                    // ar模式的修改操作
                    $data = Member::find(6);
                    //赋值属性（需要修改的字段进行赋值）
                    $data->email = 'sssss@aaa';
                    $res = $data->save();
                    dd($res);
                }

        问题：能不能用模型 去 update 呢？
        答：可以使用 update 方法进行更新，也可以使用 AR 模式的方式 进行 更细。
            public function test10(){
                //使用 DB里面的 update 方法进行更新
                $res = Member::where('id','6')->update([
                    'name' => 'xixixi',
                    'age'  => '33'
                ]);
                dd($res);
            }

    3. 删除数据
        注意：在 laravel 里面 如果需要 删除 数据（ORM模型方式），需要先调用模型的 find 方法 获取对应的记录，返回一
        个模型对象，最后调用 delete() 方法即可。
        例如代码：
            $user = User::find($id);
            return $user->delete() ? 'OK' : 'Faild';
        案例：
            删除 id=6 的 记录
                public function test11(){
                    // ar模式的修改操作
                    $data = Member::find(6);
                    dd($data->delete());
                }
                // 返回值 bool
        
        问题：DB里面的删除 方式 能否 在 模型中 使用？
            public function test11(){
                //使用 DB里面的 delete 方法进行更新
                dd(Member::where('id', '>', 2)->where('id', '<', 5)->delete());
            }
            // 返回值 影响的行数

*+++++* 自动验证【重点】
1. 准备工作
2. 验证方式 一（控制器方式验证：推荐）
    2.1 基本语法
    2.2 基本验证规则
    2.3 输出错误信息
    2.4 内容案例
    2.5 把输出效果转换成中文
