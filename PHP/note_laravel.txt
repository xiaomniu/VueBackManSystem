PHP 预定义变量：
    https://www.php.net/manual/en/reserved.variables.php

*******************    Day01    ******************
目前大部分的框架公共的特点
1. 单入口，所有的请求必须从 单入口开始，主要是便于管理（统一的参数过滤）
2. MVC的思想
3. ORM 操作数据库（Object Relations Model）：AR模式
注意：Laravel 框架有一个特点，所有 URL 访问都必须事先 定好 路由规则


php版本：7.0.12-nts

composer 方式部署 laravel 项目
    1. 切换 镜像（软件下载地址）为中国内镜像
        镜像官网：https://pkg.phpcomposer.com/
        设置中国镜像源
            composer config -g repo.packagist composer https://packagist.phpcomposer.com
        如果需要解除镜像并恢复到 packagist 官方源，请执行以下命令
            composer config -g --unset repos.packagist
        手动配置 代理  Administrator环境变量 中加入
            http_proxy=127.0.0.1:49938

    2. 创建一个名为 laravel 的 laravel项目
        composer create-project laravel/laravel --prefer-dist ./myprojectname
        composer : composer 程序
        create-project : 创建项目
        laravel/laravel : 需要创建的项目名称
        --prefer-dist : 优先下载压缩包方式，而不是 直接从 GitHub 下载源码（clone方式）
        ./myprojectname : 表示创建的项目在哪个目录

        指定版本方式：
        composer create-project laravel/laravel=5.4.* ./myprojectname --prefer-dist
        composer create-project laravel/laravel=5.4.* --prefer-dist ./myproject02

        composer create-project --prefer-dist laravel/laravel ./myproject04 "5.8.*"
        composer create-project laravel/laravel=5.8.* --prefer-dist ./myproject04
        

        更新 composer 程序
            composer self-update



*+++++* 项目 目录结构
    1. app目录：项目的核心目录，主要用于存放 核心代码，也包括控制器、模型
        比如控制器存放如下位置：app/Http/Controllers
        模型文件存放位置，模型文件直接写在 app 目录下即可，但是也可以在该目录下建立其他目录，用于专门存放模型文件，例如
            建立 Admin 目录专门存放后台需要的模型文件
            建立 Home 目录存放前台模型文件目录
        默认的模型文件  app/User.php
    2. bootstrap 目录：laravel 启动目录
        autoload.php 文件用于自动载入需要的类文件
    3. config目录，项目的配置目录，主要存放配置文件，比如数据库的配置
        App.php : 项目主要配置文件
        Auth.php : 用于定义用户认证（登录）的配置文件
        Database.php : 针对数据库的配置
        Filesystems.php : 上传文件、下载文件 存储需要使用到的配置文件
    4. database目录，数据迁移目录
        存储跟数据表相关的操作类文件（迁移文件【创建数据表的类文件】、种子文件【存放一些数据表的数据填充文件】）
    5. public目录：
        项目的入口文件和系统的静态资源目录（css,img,js,uploads）
        后期使用的外部静态文件（js、css、图片等）都需要放到 public 目录下
        注意：当然重点的是项目单一入口文件 也在 这个目录下。因此后续配置虚拟主机的时候需要将站点位置指定到 public 下
        public/robots.txt
            控制 某些网站 不允许 搜索引擎 抓包（爬数据）
    6. resources 目录，存放视图文件，还有就是语言包文件的目录
        lang 目录：语言包目录（如果项目需要本地化 则需要配置语言包）
        views 目录：视图文件存储目录（视图文件也可以分目录管理）
    7. routes目录，是定义路由的目录，web.php 是定义路由的文件
    8. storage 目录，主要是存放缓存文件和日志文件
        注意，如果在 linux 环境下，该目录 需要有可写权限。
        后期 用户 上传文件 如果存在本地 则也在 storage 下
        App：存放用户上传的文件
        Framework: 框架运行时的缓存文件
        Logs: 日志文件
    9. vendor 目录：主要是存放第三方的类库文件
        laravel 思想主要是共同的开发，不要重复造轮子（例如，里面可能存在验证码类，上传类，邮件类），该目录还存放 laravel 框架
        的源码。注意如果要使用 composer 软件管理的，composer 下载的类库 都是存放在 该目录下
    
    10. .env 文件：主要设置一些系统相关环境配置文件信息。
            config 目录里面的文件配置内容，一般都是读取该文件里面的配置信息（config里面的配置项的值基本都是来自 .env 文件）
    11. artisan 脚手架文件，主要用于生成代码的（自动生成）
            比如生成器，模型文件等。
            执行命令：php artisan 需要执行的指令
                要求1：php 必须添加环境变量，保证版本正确
                要求2：artisan 必须存在命令行当前的工作路径下
    12. composer.json 依赖包 配置文件
            声明当前需要的软件依赖，但是不能删除，composer 需要使用
    
    重点掌握的目录（频繁使用）
    目录下                          作用
    app                             保存模型文件（默认）
    app/Http/Controllers            保存控制器文件
    resources/views                 保存视图文件
    config                          配置文件目录
    routes                          存放路由文件
    database/migrations             存放数据库迁移文件（操作数据表结构）
    database/seeds                  存放数据库种子文件（模拟测试数据）

*+++++* 启动方式
    1. 指令方式启动：
        命令：php artisan serve
        不推荐使用该方式 启动
        1. 能够运行 php 代码，但是不能启动数据库
        2. 该方式启动后，如果修改了项目的配置 .env 的话，则需要重新启动才会生效
    2. 使用 wamp 或 lamp 环境
        1. 虚拟主机配置：
            修改 apache 的虚拟主机 vhost 的配置文件
            vhost文件位置：I:/serv/2017-06-13/Apache/conf/extra/httpd-vhosts.conf
            <VirtualHost *:80>
                # 配置站点管理员的邮箱，当站点产生 500 错误的时候，会显示在页面上
                ServerAdmin yiyiyi@outlook.com
                # 站点的根目录
                DocumentRoot "E:\GitRepository\VueBackManSystem\PHP\Day01\myprojectname\public"
                # 站点需要绑定的域名
                ServerName www.0223.com
                # 服务器的别名的域名
                ServerAlias 0223.com
                # 针对站点的详细的配置
                <Directory "E:\GitRepository\VueBackManSystem\PHP\Day01\myprojectname\public">
                    allow from all
                    AllowOverride all
                    Options +indexes
                </Directory>
            </VirtualHost>

        2. 修改 host文件（线上叫 DNS 域名解析）
            host文件位置：C:\Windows\System32\drivers\etc\hosts
            “127.0.0.1 www.0223.com 0223.com”
        
        3. 重启 apache

*+++++* laravel 入门使用（路由）
    什么是路由：将用户的请求按照事先规划的方案提交给指定的控制器或者功能函数来进行处理【通俗的讲，路由就是访问地址形式】
    在 ThinkPHP框架中，当我们在 URL 地址中，传递 m、c、a 三个参数时，系统会自动跳转到指定模型中 指定 控制器 的 指定方法
    这些处理过程都是由框架自动完成的。但是，在 laravel 框架中，其并没有指定固定参数，其路由必须要手工进行配置
    1. 路由配置文件
        路由文件的位置：routes/web.php 文件
    2. routes\web.php 配置文件中配置路由
        2.1. 默认根路由
            问题：为什么当我们在浏览器中访问虚拟域名 http://域名 时如何显示 Laravel5 ？
            答：主要是收到 web.php 路由的影响，当我们访问 http://域名 时，系统会自动跳转到 web.php路由，然后查看
                是否由定位到根目录下的 get 请求，找到如下代码
                // 默认根路由，当系统创建好之后就存在的
                Route::get('/', function(){
                    return view('welcome'); // view 方法，输出视图文件，相当于 $this->display()
                })
        2.2. 路由定义格式：
            Route::请求方式（'请求的URL'，匿名函数或控制响应的方法）
              比如请求域名下根目录
                Route::get('/',function(){return 'hello world'})
                函数的返回值，就是请求的响应
                // 默认根路由，当系统创建好之后就存在的
                Route::get('/', function(){
                    //return view('welcome'); // view 方法，输出视图文件，相当于 $this->display()
                    return 'hello world.';
                })
              又比如请求：http://域名/home 地址，则 路由 写成
                Route::get('/home', function(){return '您当前访问的是 /home 地址';})
                // 定义访问 /home 的路由
                Route::get('/home', function(){
                    // 输出内容
                    return '您当前访问的是 /home 地址';
                })

            ****** 注意 ******
                问题：
                    路由不起作用，只有根路由起作用，自定义路由不起作用？？
                解决：
                    1. 如果使用 nginx 则 在 文件 D:\phpstudy_pro\Extensions\Nginx1.15.11\conf\vhosts\0localhost_80.conf 中， 添加 以下配置 
                        location / {
                            try_files $uri $uri/ /index.php?$query_string;
                        }
                    2. 如果使用 apache 则 在 文件 E:\GitRepository\VueBackManSystem\PHP\Day01\myproject04\public\.htaccess 中 添加以下配置
                        <IfModule mod_rewrite.c>
                            RewriteEngine On
                            RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
                            RewriteBase /
                            RewriteRule ^index\.php$ - [L]
                            RewriteCond %{REQUEST_FILENAME} !-f
                            RewriteCond %{REQUEST_FILENAME} !-d
                            RewriteRule . /index.php [L]
                        </IfModule>
                原因：
                    使用 phpstudy_pro 默认的配置，应请求 /login , nginx 会尝试查看是否有一个名为 /var/www/html/myproject/public/login 的文件存在，那么如果一个名为 /var/www/html/myproject/public/login/ 的文件夹如果它们都不存在，则返回错误 404。
                    这不是您所期望的，因为您没有创建名为 login 的文件。 ，你刚刚在 Laravel 的路由器中创建了一个路由。因此，您必须以调用 index.php 的方式配置 nginx。每次向该虚拟主机请求时，公共(public)目录的文件，然后框架将能够将请求所针对的 URL 与您注册的路由进行比较。
                    您应该编辑您的配置以添加以下位置 block ，以便将所有请求(静态资源的请求除外)重定向到 index.php ，以原始查询为参数:
                    location / {
                        try_files $uri $uri/ /index.php?$query_string;
                    }

        2.3. 请求方式
            有效的路由方法
            我们可以注册路由来响应任何 HTTP请求：
                Route::get($url, $callback());
                Route::post($url, $callback());
                Route::put($url, $callback());
                Route::patch($url, $callback());
                Route::delete($url, $callback());
                Route::options($url, $callback());
            有时候还需要注册路由响应多个HTTP请求————这个可以通过 match 方法来实现，或者用 any 方法 注册一个路由来响应所有 HTTP请求：
                Route::match(['get', 'post'], function(){
                    //
                });
                Route::any('foo', function(){
                    //
                });
            常用的记住 四个 ：get/post/match/any
                Get : 表示支持 get 请求的路由
                Post : 表示支持 post 请求的路由
                Match : 表示匹配固定（自己定义）的请求方式的路由
                Any : 表示匹配任意请求方式的路由

                语法上 match 比 get/post/any 多一个参数
                Route::match(匹配的请求类型, 地址, 回调);
                匹配请求类型要求是数组格式的声明（建议使用短数组）
                // 使用 any 方式请求
                Route::any('/any', function(){
                    return 'any类型的请求';
                })
                // match 类型
                Route::match(['get', 'post'], '/match', function(){
                    return 'match类型的请求';
                })
    3. 路由参数
        路由参数其实就是给路由传递参数
        参数分为 必选参数 和 可选参数
            Route::get('/user/{id}', function($id){
                return "当前用户id是：".$id;
            });
            Route::get('user2/{id?}', function($id = null){
                return "当前用户id是：".$id;
            })
            补充：除了通过定义路由的方式来传递路由参数以外，还可以通过 “ ？” 形式传递参数，
                例如：http://www.0223.com/user?id=11111
                这种写法不需要将参数部分写进路由文件 web.php 中。
    4. 路由别名
        路由别名相当于在路由定义的时候，为路由起了一个别名，在以后的程序中可以通过这个别名来获取路由的信息
        例如：已有路由
            Route::get('/user/{id}', function(){
                reutrn "当前用户id是：".$id;
            })->name('名字')
            Route::any('/test5', function(){
                reutrn "当前用户id是：".$_GET['id'];
            })->name('名字')
            则 调用有名字的 路由 可以写成：route('名字')

            查看系统已经 存在的 路由
                命令：php artisan route:list
    
    5. 路由群组（理解）
        比如 后台 有 如下路由
        /admin/login
        /admin/logout
        /amdin/index
        /admin/user/add
        /admin/user/del
        ...
        他们的共同点是，都有一个 “/admin/” 前缀，为了管理方便，可以把他们放到一个路由分组中。
        使用 prefix 属性指定 路由前缀
        比如，为所有路由 URIs 前添加前缀 “admin”
            Route::group(['prefix'=>'admin'], function(){
                Route::get('users', function(){
                    return  "当前访问的是： /admin/users";
                });
            });
            语法：Route::group(公共属性数组, 回调函数)

*+++++* 控制器使用
1. 控制器文件写在哪里
    位置: app/Http/Controllers

2. 控制器文件如何命名
    依照 已经 存在的 四个规范 控制器文件名 可以得知其命名方式
    大驼峰的控制器名+Controller.php

3. 结构代码如何书写
    注意：其控制器基础结构代码，不需要手动编写，可以通过 artisan 命令行来自动生成，生成的文件默认在  app/Http/Controllers 目录中
    命令：php artisan make:controller 大驼峰的控制器名+Controller.php
    命令使用位置：当前项目的根目录下（app 或 public 目录的上级目录）
        例如：php artisan make:controller TestController
            如果需要指令生成在 app/Http/Controllers/TestDir01/TestDir02 目录下，则使用
                php artisan make:controller TestDir01/TestDir02/TestController

4. 控制器路由
    即，如何使用路由规则调用控制器下的方法，而不再 走 回调函数
    路由设置格式基本相同，只是将你能函数换成‘控制器类名@方法名’
    定义格式如下：
        Route::请求方法('路由表达式', '控制器@方法')

        例如 在 Test控制器中创建 test1 方法，其中输出 phpinfo 信息：
        class TestController extends Controller {
            // phpinfo 信息：
            public function test1(){
                return phpinfo();
            }
        }
        在 routes\web.php 文件中 加入：
        Route::get('/home/test/test1', 'TestController@test1');

5. 控制器是否可以分目录管理（支持）
    例如：需要创建前台分组 Home，在前台平台中创建 Home/indexController.php 文件，同时建立后台的分组 Admin，再创建后台的 Admin/indexController.php
        php artisan make:controller Admin/IndexController 
        php artisan make:controller Home/IndexController 
    
    routes/web.php 中加入
        Route::get('/home/index/index', 'Home\IndexController@index');
        Route::get('/admin/index/index', 'Admin\IndexController@index');

6. 接收用户输入
    接收用户输入的类：Illuminate\Support\Facades\Input
    Facades：门面的思想。门面是介于一个类的实例化与没有实例化中间的一个状态。其实是类的一个接口实现。这个
        状态下可以不实例化类，但是可以用类中的方法。
    Input::get('参数名字', '如果参数没有被传递使用该默认值')
    Input::all()  获取所有的用户输入
    Input::get('')  获取单个的用户输入
    Input::only([])  获取指定的几个用户输入
    Input::except([])  获取指定几个用户的输入以外的所有的参数
    Input::has('name')  判断某个输入的参数是否存在

    上述方法即可以获取 get 中的信息，亦可以获取 post 中信息

    导入的类的路径太长时，可以设置 别名。在 config/app.php 文件中 找到 “aliases” 配置项 最后，
        添加一行：'Input' => Illuminate\Support\Facades\Input::class,
        后续 再使用 时，就直接 写 ： use Input
    
    编写路由测试：
        在 laravel 中友好输出函数：dd()
        作用是 dump + die，后续的代码不会执行
        routes/web.php 中加入
            Route::get('/home/test/test2', 'TestController@test2');
        用户输入测试 地址：http://localhost/home/test/test2?id=235234&name=haha&age=34&gender=1
            // 获取一个值，可以加 缺省参数
            echo Input::get('id', '10086').'<br>';
            // 获取全部的值（数组的形式返回）
            $all = Input::all();
            var_dump($all);
            // dd($all); // dump + die
            // 获取指定 的信息（字符串形式）
            dd(Input::get('name'));
            // 获取指定的几个值（数组形式）
            dd(Input::only(['id', 'age']));
            // 获取 除了 指定值 之外的所有值（数组形式）
            dd(Input::except(['id', 'name']));
            // 判断 某个值  是否存在
            dd(Input::has('gender'));
        提示：在 laravel 中，不仅仅是 Input 门面 可以获取 用户的输入，Request门面 也可以获取用户输入
            他的语法和 Input 一样，也存在 get , all , only 等方法

*+++++* DB类操作数据库（重点）
    按照MVC的架构，对数据的操作应该放在 Model 中完成，但如果不适用 Model，我们也可以使用 Laravel框架提供的 DB 类操作数据库，
    而且，对于某些极其复杂的 sql，用 Model 已经很难 完成，需要开发者 自己手写 sql 语句，使用 DB 类去执行 原生 sql。laravel 中
    DB 类的基本使用方法 DB::table('tablename')，获取操作 tablename 表的实例
1. 数据表的创建于配置
    数据库字符集 使用 utf8 和 utf8-genarer-cli （utf8mb4 包含 utf8）
    1. 创建数据库 和 测试表
    create table member(
        id int primary key auto_increment,
        name varchar(32) not null,
        age tinyint unsigned not null,
        email varchar(32) not null
    ) engine myisam charset utf8;

    2. 方法 1：
        数据库在 laravel 框架中 配置（配置文件：.env 文件中）
        DB_CONNECTION=mysql
        DB_HOST=localhost
        DB_PORT=3306
        DB_DATABASE=myproject04db
        DB_USERNAME=root
        DB_PASSWORD=123456
       方法 2:
        也可以在 config 目录下的 database.php 文件里面的 mysql配置模块 配置，使用 env() 函数，表示先从 .env 文件中获取，如果获取成
        功则使用，如果获取失败，则使用 env() 函数的 第二个参数
       注意：
        database.php 的 mysql配置模块有个 strict=>true 严格模式属性，建议关闭
        如果 是 php artisan serve 方式启动的，修改了配置文件。则需要重新启动，才能读取修改后的配置文件。如果是 wamp/lamp 等环境则 无需 重启
    
    3. 在 Test 控制器中 引入 DB 门面
        DB 门面 在 app.php 中已经定义了别名 DB，可以直接使用 use DB

    4. 定义 增删改查 需要的路由
        // Route::get('/home/test/add', 'TestController@test2');
        // Route::get('/home/test/del', 'TestController@test2');
        // Route::get('/home/test/update', 'TestController@test2');
        // Route::get('/home/test/select', 'TestController@test2');
        Route::group(['prefix' => '/home/test'], function(){
            Route::get('/add', 'TestController@add');
            Route::get('/del', 'TestController@del');
            Route::get('/update', 'TestController@update');
            Route::get('/select', 'TestController@select');
        });

2. 增加信息
    对数据库中的某个表增加数据主要使用：insert()  和 insertGetId()
    insert(一维数组 或 多维数组)：可以同时添加 一条 或 多条，返回值是 布尔类型
    insertGetId(一维数组)：只能添加一条数据，返回自增 ID
    注意：
        // 指定需要操作的数据表实例
        $db = DB::table('member');
    向 member 表同时添加多条数据
        // 增加多条数据（如果单个则参数 是一维数组，多个则是 多维数组）
        $rst1 = $db->insert([
            [   'name'  => '张三', 'age'   => '23', 'email' => 'zhangsan@itcast.cn' ],
            [   'name'  => '李四', 'age'   => '24', 'email' => 'lisi@itcast.cn' ],
            [   'name'  => '王五', 'age'   => '25', 'email' => 'wangwu@itcast.cn' ]
        ]);
    向 member 表 添加 一条数据
        // 增加 一条数据
        $rst1 = $db->insertGetId([
            'name'  => '王五', 'age'   => '25', 'email' => 'wangwu@itcast.cn'
        ]);

3. 修改数据
    数据修改可以使用 update()、increment()、decrement() 函数来实现
    update() 可以修改整个记录中的全部极端
    increment()、decrement() 表示修改 数字字段 的数值（递增 或 递减），如记录 登录次数 等
    案例：
        ->where()->update()
        where 语法：（如果第二个参数运算符 是 “=”，则 “=” 可以省略不写，如：-> where(字段, 值)）
            -> where(字段, 运算符, 值)
        实际案例 1：
            //  把 id>3 的名称，修改为 '王二小'
            public function edit(){
                $db = DB::table('tablename');
                // 把 id=1 的名称，修改为 '王二小'
                $rst = $db -> where('id', '>', '3') -> update([
                    'name' => '王二小'
                ]);
                dd($rst);
            }

        实际案例 2：
            public function edit(){
                $db = DB::table('tablename');
                // 把 id > 3 的对应的 年龄 加 10
                $rst = $db -> where('id', '>', '3') -> update('age', 10);
                // 把 id < 3 的对应的 年龄 减 5
                $rst = $db -> where('id', '<', '3') -> update('age', 5);
                dd($rst);
            }
        
        返回的结果  $rst 是数据库中 真实 修改了  多上条 记录的 条数

4. 查询数据
    4.1 取出基本数据
        案例 1：
            获取 member 表中 所有的数据
                DB::table('member')->get(); // 相当于 select * from member;
            返回值 是一个 集合对象:
                Illuminate\Support\Collection {#232 ▼
                #items: array:3 [▼
                    0 => {#234 ▼
                    +"id": 1
                    +"name": "张三"
                    +"age": 18
                    +"email": "zhangsan@itcast.cn"
                    }
                    1 => {#236 ▼
                    +"id": 2
                    +"name": "李四"
                    +"age": 19
                    +"email": "lisi@itcast.cn"
                    }
                    2 => {#237 ▼
                    +"id": 3
                    +"name": "王五"
                    +"age": 25
                    +"email": "wangwu@itcast.cn"
                    }
                ]
                }
        案例 2：
            获取 id<3 的数据
                $data = $db -> where('id', '<', '3') -> get();
            注意：where 方法之后 继续调用 where 方法：
                ->where()->where()->where()         语法的查询条件 是  且 &&
                ->where()->orWhere()->orWhere()     语法的查询条件 是  或 ||
                orWhere() 函数的 参数 和 where() 一致

        Get() 查询的结果每一行 的记录是 对象的形式，不是数组。

    4.2 取出单行数据
        DB::table('member')->first(); //返回值是一个 对象
        等价于 limit 1

    4.3 获取某个具体的值
        DB::table('member')->where('id','1')->value('name');
        
    4.4 获取某些字段数据
        $user = DB::table('member')->select('name','email')->get();
        $user = DB::table('member')->select('name as user_name')->get();

    4.5 排序操作
        DB::table('member')->orderBy('age','asc')->get();  // asc  升序
        DB::table('member')->orderBy('age','desc')->get(); // desc 降序

    4.6 分页操作（限制输出记录数）
        DB::table('member')->offset(2)->limit(3)->get();    // 从 get() 获取的集合中 从 第2条 数据后的   第 3 条 到 第 6 条，共 3 条数据
        limit：表示 限制输出的条数
        offset：从什么地方开始

5. 删除数据（delete）
    删除分两种： 物理删除  和  逻辑删除
    数据删除可以通过 delete()函数 和 truncate()函数 来实现
    Delete() 表示删除记录
        DB::table('member')->where('id','1')->delete();
        返回的结果  $rst 是数据库中 真实 修改了  多上条 记录的 条数
    Truncate() 表示清空整个数据表
        DB::table('member')->truncate();
        返回的结果  $rst 是 null

6. 执行任意的SQL语句
    1. 执行任意的 insert update delete 语句【影响记录的语句使用 statement 语法】
        DB::statement("insert into member values(null,'')");
    2. 执行任意的 select 语句【不影响记录的语句使用 select 语法】
        $rst = DB::select("select * from member");

*******************    Day02    ******************
*+++++* 视图操作【重点】
1. 视图写在哪里
    位置：resources/views
    可以进行分目录管理

2. 视图文件的命名与渲染
    (1) 文件名 习惯 小写
    (2) 文件名的后缀是 .blade.php（因为 laravel 里有一套模板引擎 就是 使用 blade，可以直接使用标签语法 {{$title}}，也可以使用原生 php 语法显示数据
    (3) 需要注意的是也可以使用 .php 结尾，但是这样的话就不能使用 laravel 提供的标签 {{$title}} 语法显示数据，只能用原生语法 <?php echo $title; ?> 显示数据
    两个视图文件可以同时存在，则 .blade.php 后缀的优先显示出来
    案例：
        编写一路由地址，调用控制器的 test3() 方法，展示视图 test3文件（创建 2 个，一个 .blade.php 结尾，另一个 .php 结尾）
        新增路由：
            Route::get('/home/test/test3', 'TestController@test3');
        展示 视图的方法：
            return view('视图文件名称');
            视图可以进行 分目录管理的，如 home/test/test3 视图，可以 写成
                return view('home/test/test3');   或者 
                return view('home.test.test3');

3. 变量分配与展示
    控制器 和 视图  要进行 数据 交互
    语法：
        1. view(模板文件名称, 数组)         // 这个 “数组”，就是我们需要 分配的变量 键值对 集合
        2. view(模板文件名称)->with(数组)
        3. view(模板文件名称)->with(名称, 值)->with(名称, 值)
        使用 view() 方式 渲染 一个视图后，在 .blade.php 的视图文件中，模板中输出变量使用 “{{$变量}}”
            $date = date('Y-m-d H:i:s', time());
            $day = '星期二';
            return view('home.test.test3', ['date'=>$date, 'day'=>$day]);
        在视图 test3.blade.php 文件中 展示 传递的变量
            现在是时间是:{{$date}}，今天是 {{$day}}

4. 扩展：compact() 函数的使用（传参）
    compact() 函数，是 php 内置函数 跟 laravel 框架没有关系。作用主要是用于打包数组的。
    语法：compact('变量名1', '变量名2', '变量名3', ...)
    改写上面的代码：
        $date = date('Y-m-d H:i:s', time());
        $day = '星期二';
        return view('home.test.test3', compact('date', 'day'));

5. 模板中直接使用函数
    回顾：在 smarty 模板引擎中存在一个特殊的符号 “|”（管道），名称 称之为 变量修饰符。作用就是在 视图中 解释变量（使用函数去处理变量）
    在 laravel 中，视图调用函数 其语法 基本 与 js、php 的语法一致，只不过要求 左右包含 大括号。
    语法：{{ 函数名(参数1, 参数2, ...) }}
    说明：函数名 可以是 php 内置的，也可以是 laravel 框架中定义的
    案例：
        在数据库中一般存储时间都是以时间戳 去储存的，但是在页面上展示的时候 不合适。就需要 对其格式化处理。
        需要在 视图中 对其格式化 则怎么写？
            一年后的时间是：{{ $time }} 格式化后：{{ date('Y-m-d H:i:s', $time)}}

        如果需要使用更多的函数，则需要遵循函数的语法格式即可

6. 循环与分支语法标签【重点】
    // 在视图里面遍历数据【重点】
    在 laravel 中模板中 循环输出数据，则需要 遵循 语法：
        // php写法
        foreach ($varialbe as $key => $value){
            // 循环体
        }

        // laravel 中 视图中 写法
        @foreach ($varialbe as $key => $value)
            // 循环体
        @ endforeach
    案例：
        使用循环标签的语法，在视图中输出数据
        新增路由：
            Route::get('/home/test/test4', 'TestController@test4');
        创建需要的方法，获取一些数据，传递给视图
            // 循环标签
            public function test4(){
                // 查询数据
                $data = DB::table('member')->get();
                // 展示视图，传递数据
                return view('home.test.test4', compact('data'));
            }
        创建 需要的 视图文件
            home/test/test4.blade.php，文件中加入 以下 代码
                @foreach ($data as $key => $value)
                    {{$value->id}}&emsp;&emsp;{{$value->name}}&emsp;&emsp;{{$value->age}}&emsp;&emsp;{{$value->email}}<br>
                @endforeach
        在此过程中需要注意的就是 get 查询到的结果 集中每一条记录 其实都是一个对象。
        因此在循环具体字段的时候需要注意使用 对象调用属性 的方式 才可以 获取其数据。

    // 在视图里面可以执行 if 判断【重点】
    if 语法在模板引擎中的写法：
        // php 中写法
        if (条件判断) { }
        elseif (条件判断) { }
        else { }

        // laravel 中 视图中 写法
        @if (条件判断) { }
        @elseif (条件判断) { }
        @else { }
        @endif

    案例：
        要求在 php 代码中（控制器的方法）动态输出 今天的 星期几 的 数字（1~7），将数字传递给视图。显示出今天是 星期几。如果是 7
        则在页面中输出 “星期天”【将数字转化成汉字】

7. 模板 继承 / 包含  1.01.30
    继承 不仅仅在 php 类中存在，在视图中同样存在。一般是用于做 有公共部分的页面
    案例：
        编写父级页面，再编写一个子页面（相当于php中的 2 个类）
            编写父级页面：
                语法： @yield('名字')       在父级页面中的占位
        继承语法：
            字模板中按以下语法书写：
                @extends('需要继承的模板文件名')
                如：
                    @extends('home.test.parent')
            通过 section 标签 绑定区块/部件 到父级页面，区块 名称 就是 父级页面 yield 标签的 参数名。
                @section(区块名称)
                代码
                @endsection
                如
                    @section('mainbody')
                    <div>
                        科阿斯兰的放假啦空手道解放考虑按实际开来
                    </div>
                    @endsection

    包含
        语法：@include('模板文件名')                文件名不含后缀，语法类似 view 方法参数
        如：
            <h1>BBBB</h1>
            @include('home.test.test4')
            <h1>CCCC</h1>
            @include('home.test.parent')
            <h1>DDDD</h1>

8. 外部静态 文件 引入方式（了解）
    在写页面肯定会 引入相关的外部文件（js、css、image），则会设计到 路径的问题。
    以下面这个 app.css 为例，看如何去引入 css 文件
        以往的方式：
            <link rel="stylesheet" type="text/css" href="/css/app.css">
        laravel 视图文件中 的方式
            <link rel="stylesheet" type="text/css" href="{{asset('css')}}/app.css">
    Asset 方法中的参数可以是 多级目录 也可以是 单击目录。
        <link rel="stylesheet" type="text/css" href="{{asset('css/abc/def')}}/app.css">

*+++++* CSRF攻击
1. 什么是 CSRF 攻击
    CSRF 是 跨网站请求伪造（Cross-Site request forgery）的英文缩写
    Laravel 框架中避免 CSRF 攻击，很简单：Laravel 自动为 每个用户 Session 生成了一个 CSRF Token。
    该 Token 可用于验证登录用户 和 发起请求者是否是 同一个人，如果不是 则请求失败。【该原理和 验证码 原理一致】
    Laravel 提供了一个全局帮助函数 csrf_token 来获取该 Token 值，
    因此 只需要在视图提交表单中 添加 如下 HTML 代码，即可 在请求中 带上 Token：
        <input type="hidden" name="_token" value="<?php echo csrf_token(); ?>
                  
2. laravel中 如何避免 CSRF 攻击
    创建 路由 
        // csrf 验证
        Route::get('/home/test/test6', 'TestController@test6');
        Route::post('/home/test/test7', 'TestController@test7');
    创建 控制器 的方法
    // 展示 基础的 表单
        public function test6(){
            // 
            return view('home.test.test6', compact('data', 'day'));
        }
        // 处理请求
        public function test7(){
            return '请求提交成功';
        }
    创建需要的简易表单
        <form action="{{route('test7')}}" method="post">
            姓名：<input type="text" name="name" value="" placeholder="请输入姓名"><input type="submit" value="提交">
        </from>

    结论：通过刚才的案例，说明在 laravel 中 csrf 验证机制默认是开启的

    解决 报错问题（如何通过 csrf 验证）
        带上 csrf 需要的 token 值。随着 请求传递给 后续的方法
        <input type="hidden" name="_token" value="{{csrf_token()}}">
    
    针对 csrf_token() 方法 的 简化：
        {{ csrf_field()}}
        等价于  “<input type="hidden" name="_token" value="{{csrf_token()}}">”
    两者的区别
        csrf_token 只是 输出 token 的值
        csrf_field 输出了 一个 整个 input 隐藏域
        当使用 异步提交表单的 方式 时：必须使用 csrf_token()
            如：$.get(rul, {{_token}});
        
3. 从 CSRF 验证中 排除 例外路由
    并不是 所有请求都需要 避免 CSRF 攻击，比如去 第三方 API 获取数据的 请求。
    可以通过在 VerifyCsrfToken.php（app\Http\Middleware\VerifyCsrfToken.php）文件中，将要排除 请求 URL 添加到 $except 属性数组中。

    如果 需要 排除 全部 路由 使用 csrf 的话，使用 “” 通配符，加入到 $except 属性数组中。
        protected $except = [
            // 这里 添加 需要 排除 csrf 验证的 路由
            '*'
        ];

*+++++* 模型操作（AR模式）【理解】
    Laravel 自带的 Eloquent ORM 提供了一个美观、简单的数据库打交道的 ActiveRecord 实现，每张数据表 都对应一个与该表进行交互的“model模型”，
    模型 允许你 在表中进行数据查询，以及 插入、更新、删除 等操作
    AR模式三个核心（映射）：
        每个数据表              与数据进行交互的 model 模型映射（实例化模型）
        记录中的字段            与模型类的属性映射（给属性赋值）
        表中的每个记录          与一个完整的请求实例映射（具体的CURD操作）

1. 定义模型
    定义模型的位置：默认 在 app 目录下，建议使用  分目录管理
    命名规则：
        本身 laravel 对模型的命名没有严格的要求，一般采用 表名（首字母大写）.php 。比如：Member.php User.php Goods.php
    创建模型
        可以使用 artisan 命令
        php artisan make:model Member
    定义模型的注意事项：【重点】
      （必做 protected）  第一：定义一个 $table 属性，值是不要前缀的表名，如果不指定则使用 类名的 复数形式作为 表名。
                    如果 模型为 Member，模型在不指定 table 属性时，默认会去找 Members 表名。
      （可选 protected）  第二：定义 $primaryKey 属性，值是 主键名称，如果需要使用 AR 模式的方法，则需要指定主键（Model::find(n)）
                    在主键 字段 不是 id 的时候，则需要 指定 主键
      （可选 public   ）  第三：定义 $timestamps 属性，值是 false，如果不设置为 false，则 默认会操作表中 created_at 和 update_at 字段。
                    我们表中一般没有这 两个 字段，所以设置为 false，表示不要操作 这两个字段
      （可选 protected）  第四：定义 $fillable 属性，表示使用 模型插入数据时，允许插入到数据库的字段信息。
    注意：
        使用模型中 create 插入数据时，要设置 $fillable 允许 入库的 字段。使用 $guarded 是设置 排除 入库的 字段
            //定义 模型关联的数据表（一个模型 只操作  一个表）
            protected $table = 'member';
            //定义 主键（可选）
            protected $primaryKey = 'id';
            //定义 禁止操作 时间
            public $timestamps = false;
            //设置 允许写入的 数据字段
            protected $fillable = ['id', 'name', 'age', 'email'];

2. 模型控制器中调用
    引入模型类：
        use App\Home\Member;
        模型的使用，在控制器中 的 使用方式 有 2 种：
            1. 直接像 使用 DB门面 一样的操作方式：以调用静态方法为主的形式，该形式下模型不需要实例化
                如：Member::get()    DB::table('member')->get()
            2. 实例化模型然后 再去使用模型类（普通）
                如：$model=new Member();  $model->get();

3. 定义测试路由
    // 模型的增删改查
    Route::post('/home/test/test8', 'TestController@test8');
    Route::get('/home/test/test9', 'TestController@test9');
    Route::get('/home/test/test10', 'TestController@test10');
    Route::get('/home/test/test11', 'TestController@test11');

    Route::get('/home/test/test12', 'TestController@test12');

4. 基本操作
    1. 添加数据
        在 laravel 里面完成数据的添加 可以使用 两种 方式：
        方式一：（AR模式）：使用 AR 模式必须要实例化模型
        注意：
            在 Laravel 里面添加数据的时候，需要先实例化模型，然后为模型设置属性，最后调用 save 方法即可。
            $member = new Member();         // 映射 关系 1：将表 映射到 模型
            $member->name = value;          // 映射 关系 2：将字段映射到属性，属性名 和 字段名 一致
            $member->save();                // 映射 关系 3：将记录映射到实例
        如：
            public function test8(){
                // 实例化 模型，将 表 和 属性 映射 起来
                $model = new Member();
                // 给属性赋值，将字段 与 类的 属性 映射起来
                $model -> name = '李逵';
                $model -> age = '34';
                $model -> email = 'likui@afs.com';
                $res = $model -> save();
                dd($res);
            }
        
        上面的 这种方法可以完成 数据的插入，但是 不建议使用。

        方式二：
        先建立个建议的表单
            <form action="/home/test/test8" method="post">
                <p>姓名：<input type="text" name="name" value=""></p>
                <p>年龄：<input type="text" name="age" value=""></p>
                <p>邮箱：<input type="email" name="email" value=""></p>
                {{ csrf_field() }}
                <input type="submit" value="提交">
            </from>
        首先，在控制器文件引入 Request 这个类
            use Illuminate\Http\Request;
            Request 类使用：(与前面的 input 门面 类似，Input调用的是静态方法 获取路由地址上传的参数)
                对象 传递
                request 语法
                $request->all()
                $request->input('name')
                $request->only(['name', 'id'])
                $request->except(['name', 'gender'])
                $request->has('name')
                $request->get('name')
            添加操作代码语法如下：
                静态调用：Member::create($request->all()) //返回值 是一个对象
                实例调用：$model->create($request->all()) //返回值 是一个对象
        注意：
            如果使用 create方法，则需要在模型中定义 fillable 属性，允许写入字段的定义，如果没有时间相关字段也需要禁用时间自动更新功能
                // 禁用时间自动更新功能
                public $timestamps = false;
                // 使用 create方法，则需要在模型中定义 fillable 属性，允许写入字段的定义
                protected $fillable = ['id', 'name', 'age', 'email'];
        public function test8(Request $request){
            // 实例化 模型，将 表 和 属性 映射 起来
            $model = new Member();
            $inputData = $request->all(); // 直接从 表单上 获取所有 输入信息，返回一个 数组
            $res = $model->create($inputData);
            dd($res);
        }

    2. 查询操作
        获取指定主键的一条数据
            $info = Member::find(4); // 静态方法调用，获取主键 为 4 的数据
            public function test9(){
                $data = Member::find(4);
                dd($data->name);
                dd($data);
            }
            其 结果集 默认是 一个对象
            如果需要在 laravel中 对象的结果集 转化为数组，则需要在最终添加方法的调用：
                ->get()->toArray();
                例如：$data = Member::find(4);

        获取符合指定条件的 第一 条数据
            Member::where('id', '>', 4)->first()
            如：
            public function test9(){
                // $data = Member::find(4);
                // dd($data->name);
                $data = Member::where('id', '>', 7)->first();
                dd($data->toArray());
            }
        
        查询多行　并且　指定字段
            Member::all()
            Member::all([字段1, 字段2])         // 与 get 方法的区别，all 不支持连接其他的辅助查询方法
            相当于 get 方法
            Member::get()
            Member::get([字段1, 字段2])

            按条件查询指定多个字段
            Member::where('id', '>', 2)->get(['列1', '列2'])        // 数组选列
            Member::where('id', '>', 2)->select('列1', '列2')->get()        // 字符串选列
            Member::where('id', '>', 2)->select(['列1', '列2'])->get()        // 字符串选列
            
    3. 修改数据
        注意：在 laravel 里面 如果需要更新数据（ORM模型方式），需要先调用模型的 find 方法 获取对应的记录，返回一
        个模型对象，然后为该模型对象 设置要更新的数据（对象属性），最后调用 save() 方法即可。
        例如：
            $user = User::find($id);
            $user->title = $_POST['title'];
            $user->content = $_POST['content'];
            return $user->save() ? 'OK' : 'Faild';
        案例：
            实现 ORM形式 模型的修改操作。修改 id=6 的用户的 邮箱为：ssss@aaa
                public function test10(){
                    // ar模式的修改操作
                    $data = Member::find(6);
                    //赋值属性（需要修改的字段进行赋值）
                    $data->email = 'sssss@aaa';
                    $res = $data->save();
                    dd($res);
                }

        问题：能不能用模型 去 update 呢？
        答：可以使用 update 方法进行更新，也可以使用 AR 模式的方式 进行 更细。
            public function test10(){
                //使用 DB里面的 update 方法进行更新
                $res = Member::where('id','6')->update([
                    'name' => 'xixixi',
                    'age'  => '33'
                ]);
                dd($res);
            }

    3. 删除数据
        注意：在 laravel 里面 如果需要 删除 数据（ORM模型方式），需要先调用模型的 find 方法 获取对应的记录，返回一
        个模型对象，最后调用 delete() 方法即可。
        例如代码：
            $user = User::find($id);
            return $user->delete() ? 'OK' : 'Faild';
        案例：
            删除 id=6 的 记录
                public function test11(){
                    // ar模式的修改操作
                    $data = Member::find(6);
                    dd($data->delete());
                }
                // 返回值 bool
        
        问题：DB里面的删除 方式 能否 在 模型中 使用？
            public function test11(){
                //使用 DB里面的 delete 方法进行更新
                dd(Member::where('id', '>', 2)->where('id', '<', 5)->delete());
            }
            // 返回值 影响的行数

*+++++* 自动验证【重点】
    一般一个框架都会提供自动验证的机制。在 TP 里面的验证的规则是 写在模型里面进行验证的，但是自 laravel 里面的思想有些不一样。
    他的验证规则可以写在控制器里面，也可以单独写一个专门的验证文件。
    并且 laravel 里面的验证不通过情况下的 提示信息 和 表单数据 是保存在 session 里面的。
    并且验证不通过的情况下 会跳转 到 上一个页面。
    在前端页面中可以通过 JavaScript 验证表单的数据有效性。但是如果用户的浏览器版本过低 或者 禁用了 JavaScript，
    则前端验证则可能失效，这样就不能保证数据的有效性。所以后端也需要做响应的验证操作，
    这个操作在 laravel 中称之为 自动验证【在ThinkPHP 中也有 自动验证】

1. 准备工作
    1. 可以使用表单的页面（视图），此处新建视图 test13.blade.php 模板文件
        创建需要的 路由 和 方法：
            // 自动验证（二合一：即展示视图，又做数据处理，自己提交给自己
            Route::any('/home/test/test13', 'TestController@test13');
            //自动验证
            public function test13(){
                return view('home.test.test13');
            }

2. 验证方式 一（控制器方式验证：推荐）
    建议 查看手册：HTTP层--验证 章节 
        （https://docs.golaravel.com/docs/5.3/validation）
        （https://learnku.com/docs/laravel/5.8/validation/3899）
    2.1 基本语法
        使用 控制器中的 validate 方法来完成，
            $this->validate($request, [验证规则]);
        如果验证失败，laravel 会自动将用户重定向 回 上一个位置，并将验证错误信息 一次性 存放到 session 中
        请求验证：
            Laravel 提供了多种不同的处理方法来对应用程序传入的数据进行验证。
            默认情况下，Laravel 的基底控制器类使用了 ValidatesRequests trait，
            其提供了一种便利的方法来使用各种强大的验证规则验证传入的 HTTP 请求。
                public function store(Request $request) {
                    $this->validate($request, [
                        'title' => 'required|unique:posts|max:255',
                        'body' => 'required',
                    ]);
                    // The blog post is valid, store in database...
                }
        扩展补充：
            如何 得知 一个请求类型？
            语法：Input::method()           返回值： 'GET' 或 'POST'
    2.2 基本验证规则
        required: 不能为空
        max:255 最长255个字符
        min:1 最少1个字符
        email: 验证邮箱是否合法
        confirmed: 验证两个字段是否相同，如果验证的字段是 password，则必须输入一个预支匹配的 password_confirmation 字段
        integer: 验证字段必须是整形
        ip: 验证字段必须是 IP 地址
        max:value 验证字段必须小于等于 给定值value值，和字符串，数值，文件字段的 size 规则一样使用
        min:value 验证字段必须大于等于 给定值value值，和字符串，数值，文件字段的 size 规则一样使用
        size:value 验证字段必须有和给定值 value 想匹配的尺寸，
            对字符串而言，value 是相应的 字符数目，
            对数值而言，value 是给定的 整型值，
            对文件而言，value 是相应的文件 字节数
        string: 验证字段必须是 字符串
        alpha：字段必须是 字母
        numeric: 验证字段必须是数值
        unique: table,column,except,idColumn
        注意：
            多个 验证规则 可以通过 “|” 字符进行隔开
        代码案例：
            //自动验证
            public function test13(Request $request){
                // 判断请求类型
                // echo Input::method();
                if (Input::method() == 'POST'){
                    // 自动验证
                    $this->validate($request,[
                        // 具体的规则
                        // 字段 => 验证规则1|验证规则2|验证规则3|...
                        'name'      => 'required|min:2|max:20',
                        'age'       => 'required|integer|min:1',
                        'email'     => 'required|email'
                    ]);
                    echo '输入的信息 没有问题';
                }else{
                    // 展示视图
                    return view('home.test.test13');
                }
            }

    2.3 输出错误信息
        如果本次请求的参数未通过我们指定的验证规则呢？正如前面所提到的，Laravel 会自动把用户重定向到先前的位置。
        另外，所有的验证错误会被自动 闪存至 session。
        再者，请注意在 GET 路由中，我们无需显式的将错误信息和视图绑定起来。这是因为 Lavarel 会检查在 session 数据中的错误信息，然
        后如果对应的视图存在的话，自动将它们绑定起来。
        变量 $errors 会成为 Illuminate\Support\MessageBag 的一个实例对象。要获取关于这个对象的更多信息
        注意：
            $errors 变量被 Illuminate\View\Middleware\ShareErrorsFromSession 中间件绑定到视图，
            该中间件由 web 中间件组提供。当这个中间件被应用后，在你的视图中就可以获取到 $error 变量，
            使得你方便的假设 $errors 变量总是已经被定义好并且可以安全的使用
        例子中，当验证失败的时候，用户将会被重定向到 create 方法，让我们在视图中显示错误信息：
            <!-- /resources/views/post/create.blade.php -->
            <h1>创建文章</h1>
            @if (count($errors) > 0)
                <div class="alert alert-danger">
                    <ul>
                        @foreach ($errors->all() as $error)
                            <li>{{ $error }}</li>
                        @endforeach
                    </ul>
                </div>
            @endif
            <!-- 创建文章的表单 -->

    2.4 内容案例
        定义验证规则：
        输出错误信息：
        实际演示效果：
        到目前位置，验证的效果以及提示信息已经展示在页面上了，接下来将 显示信息 优化为 中文提示

    2.5 把输出效果转换成中文
        由于中文和英文都是语言范畴，如果要切换提示文字，则需要有中文语言包的支持。目前框架只有 en 语言包，
        下载其他语言包 在 以下网址有下载
        网址：https://packagist.org     composer 主要的代码托管网站
        在官网 搜索 laravel-lang
        注意：
            后期下载软件依赖的时候，选 下载量最好  和 收藏量最高 的包下载

            Laravel 5.8	        composer require caouecs/laravel-lang:~4.0
            Laravel 5.1-5.7	    composer require caouecs/laravel-lang:~3.0

        语言包下载好后，文件存储在 vendor/caouecs/laravel-lang 中
            vendor/caouecs/laravel-lang/auth.php
            vendor/caouecs/laravel-lang/pagination.php
            vendor/caouecs/laravel-lang/passwords.php
            vendor/caouecs/laravel-lang/validation.php

        接着将 需要的 中文语言目录 zh-CN 复制到 resources/lang 目录下即可
        修改配置文件 config/app.php 中的 'locale' => 'en' 修改为  'locale' => 'zh-CN'
        注意：
            并不是 所有的字段都有对应的 翻译（或者翻译不准确），如果想自己定义翻译，则需要，手动修改 语言包文件代码
            有关 自动验证 的 在 “vendor/caouecs/laravel-lang/validation.php” 文件中


*******************    Day03    ******************
*+++++* 文件上传
    在 laravel 里面实现文件的上传时很简单的，压根不用引入第三方的类库
    作者把 上传 作为一件 简单 的 http 请求看待的。使用时可以参考收藏
    1. 修改表结构，添加一个字段
        alter table member add column avatar varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL AFTER email;
    2. 创建 添加数据的表单 和 路由
        // 文件上传
        Route::any('/home/test/test14', 'TestController@test14');
        
        //文件上传
        public function test14(Request $request){
            // 判断请求类型
            if (Input::method() === 'POST'){
                // 获取 传送过来的 文件信息 使用 $_FILES
                // dd($_FILES);
                // dd($request->file('avatar')); // $request->file('avatar') 返回的是  Illuminate\Http\UploadedFile 对象
                if ($request -> hasFile('avatar') && $request -> file('avatar') -> isValid() ) {
                    // 获取 文件的 原始 名称
                    // dd($request->file('avatar')->getClientOriginalName());
                    // 获取文件的 大小 单位 Byte
                    // dd($request->file('avatar')->getClientSize());
                    $houZhui = $request->file('avatar')->getClientOriginalExtension();
                    $filePath = md5(time() . rand(100000, 99999)) . '.' . $houZhui;
                    $request->file('avatar')->move('./uploads',  $filePath);

                    // 获取全部的数据
                    $data = $request->all();
                    // dd($data);
                    // 此时 $data 里的 avatar 属性中的 值 是一个 Illuminate\Http\UploadedFile 对象
                    $data['avatar'] = './uploads' . $filePath;  // 这里 将  $data 里的 avatar 属性 的值 重新赋值 为 文件名 字符串
                    // dd($data);
                    $res = Member::create($data);
                    dd($res);
                }
            }else{
                // 展示视图
                return view('home.test.test14');
            }
        }
        回顾：
            要想表单能够上传（此处不考虑异步方式），则表单应该具备哪些要求？
        答：
            1. 具有 from 标签，method 必须为 post，必须具备 enctype 属性
            2. 至少 有一个 input 类型 为 file 的标签
            3. 的具备一个提交按钮

    3. 在控制器中，添加上传业务处理逻辑
        【此操作建议查看手册】 地址：https://learnku.com/docs/laravel/5.3/requests/1164#files
        关于 上传错误状态码 error 的取值：0 ~ 7 （没有 5，0 表示成功，其它的 都有问题）
        思路：
            1. 先去判断文件是否 正常 和 存在
            2. 获取相关的信息（可选）
            3. 保存文件（其实就是 移动文件 到 新的 目录）

    4. 创建上传文件的保存路径
        在 public 目录下 新建 目录：/public/uploads
        关于项目中 使用路径的说明：
            如果 路径 是给 php 代码 使用的，则路径 建议使用 “./” 形式
            如果 路径 是给 浏览器 使用的，则建议使用 “/” 形式

    5. 注意：
        如果使用的时 create 方法添加数据到数据表中，则这里还需要修改以下 模型 里面的 一个 fillable 属性，代码允许插入到数据库的 字段

    6. 将数据写入 数据库中
        // 获取全部的数据
        $data = $request->all();
        // dd($data);
        // 此时 $data 里的 avatar 属性中的 值 是一个 Illuminate\Http\UploadedFile 对象
        $data['avatar'] = './uploads' . $filePath;  // 这里 将  $data 里的 avatar 属性 的值 重新赋值 为 文件名 字符串
        // dd($data);
        $res = Member::create($data);
        dd($res);
    
    7. 如果上传 出现了 错误，一定要 获取错误 信息的方法：
        $request->file('avatar') ->getErrorMessage(); // 返回 丰富的 上传数据的 错误信息

*+++++* 数据分页
    在 laravel 里面 要完成 分页 是 很简单的。它的思想 之前的框架 有些不一样，之前框架 使用 的是 分页类 完成 分页，laravel 是直
    接调用 模型的 分页方法。返回 对应 的数据 和 分页 的字符串。
    分页类的 在框架中的位置（了解）
        vendor\laravel\framework\src\Illuminate\Pagination\Paginator.php
    案例：
        使用 分页功能 实现当前 member 数据表的 分页效果。
        由于 数据量较少，可以考虑每页显示 一条记录，重点是 分页的效果

    回忆：
        分页效果的实现大致需要哪些步骤？
        1. 查询 符合 分页条件 的 总的 记录数
        2. 计算总的 页数（总记录数 / 每页记录数，并向上取整）
        3. 拼凑分页的连接
        4. （核心）使用 limit 语法来限制 分页的记录数
        5. 展示分页的页码和分页数据
        6. 考虑分页的样式 显示问题

    1. 创建路由，并且展示建议列表页面(table 标签 布局) 
        // 数据分页（异步分页，即 Ajax 分页，可能 再次 发生请求，需要 使用  post）
        Route::get('/home/test/test15', 'TestController@test15');

    2. 编写控制器中的方法代码，实现没有分页的效果（先不考虑分页效果）
        // 数据分页
        public function test15(Request $request) {
            // 查询所有数据
            $data = Member::get();
            // 展示视图 并传递数据
            return view('home.test.test15', compact('data'));
        }

    3. 展示数据
        后期 涉及 到 路径 需要注意 点 “.” ：就是 路径的 点 的问题
            @foreach ($data as $item)
                <tr>
                    <td>{{ $item->id }}</td>
                    <td>{{ $item->name }}</td>
                    <td>{{ $item->age }}</td>
                    <td>{{ $item->email }}</td>
                    {{-- <td>{{ $item->avatar }}</td> --}}
                    <td><img src="{{ ltrim($item->avatar, '.') }}" width="80px" alt=""></td>
                </tr>
            @endforeach

        记忆：
            如果这个路径是给 php 代码使用，则一定使用 “./” 形式
            如果 给 html（前端） 使用，则一定使用 “/” 形式
            但是在 数据表中（存储的过程）使用哪种形式也就无所谓了

    4. 案例：
        使用 分页展示 上述 页面（要求：每页显示一条 记录）
        在 laravel 中 分页 有 2 个 提供者：DB 查询构建器，另一个 使用  模型 来实现（用法基本一致）
        1. 以 模型 为例：
            文档地址：https://learnku.com/docs/laravel/5.3/pagination/1188

            基于 Eloquent 模型分页
            你可能需要对 Eloquent 分页。在这个例子中，我们将把 User 模型进行分页并且设置其每页有 15 条数据，如你所见，语法跟查询语句构造器的分页语法几乎一样：

            $users = App\User::paginate(15);
            当然，你可以在设置一些约束后再使用 paginate 分页，我们使用 where 举例：

            $users = User::where('votes', '>', 100)->paginate(15);
            或者也可以在使用 Eloquent 模型进行分页时使用 simplePaginate 方法：

            $users = User::where('votes', '>', 100)->simplePaginate(15);

            分页的基本语法：
                Model::paginate(每页显示的记录数) 同样，paginate 和 get 一样，支持使用 where 以及 orderBy 等辅助查询的方法。
            
            在页面中 展示 分页 链接
                显示分页结果
                当你调用查询构建器或 Eloquent 查询上的 simplePaginate 或 paginate 方法时，你将会获取一个分页实例，当调
                用 paginate 方法时，你将获取 Illuminate\Pagination\LengthAwarePaginator ，而调用方
                法 simplePaginate 方法时，将会获取 Illuminate\Pagination\Paginator 实例。这些对象提供相关方法描述这些结果集，
                除了这些帮助函数外，分页器实例本身就是迭代器，可以像数组一样对其进行循环调用。总之，一旦你获取到结果，
                就可以对结果进行显示，并使用 Blade 渲染页面的链接：

                <div class="container">
                    @foreach ($users as $user)
                        {{ $user->name }}
                    @endforeach
                </div>
                {{ $users->links() }}

                links 方法将给予查找结果中其它页面的链接。每一个链接中都已经包含正确的 ?page 查找字符串变量。请记住，由 links 方法
                生成的 HTML 兼容于 Bootstrap CSS 框架。
                语法：
                    {{ $保存数据的对象 -> links() }} 生成的链接，显示分页页码

            将 上下 页面跳转提示 改为 中文文字“上一页”，“下一页”。则 需要修
            改 源文件 “vendor\laravel\framework\src\Illuminate\Pagination\resources\views\default.blade.php” 中的
                &lsaquo; 值 修改为  上一页 或 下一页
            
            可以使用 simplePaginate() 进行简单的分页，只有 上一页 和 下一页，没有 中间的分页字符串
            #info = Member::orderBy('age', 'desc')->simplePaginate(2);
                分页数据对象的其他使用方法：
                    Member::paginate(2)->count();                   // 当前 页 数据条数
                    Member::paginate(2)->current();                 // 当前 页码
                    Member::paginate(2)->firstItem();               // 当前 页 第一条数据 的序号
                    Member::paginate(2)->hasMorePages();            // 是否 有后续页码
                    Member::paginate(2)->lastItem();                // 当前页 最后一条数据 的序号
                    Member::paginate(2)->lastPage();                // 最后页 序号
                    Member::paginate(2)->nextPageUrl();             // 下一页 的 链接 地址
                    Member::paginate(2)->perPage();                 // 每页 显示 数据 条数
                    Member::paginate(2)->previousPageUrl();         // 上一页 的 链接 地址
                    Member::paginate(2)->total();                   // 记录总条数
                    Member::paginate(2)->url(5);                    // 制作 指定 页码数 的 链接地址

            在 百度上 搜索 现成 的 分页导航 按钮 样式

*+++++* 验证码
    回顾：生成 验证码 需要 经过：画画布、生成干扰线、生成噪点、生成验证码、生成验证码存入 session、输出图片。
1. 验证码依赖 安装
    https://packagist.org 中搜索 captcha
        https://packagist.org/packages/mews/captcha
        命令：composer require mews/captcha
        环境要求：
            在 Windows 中，您需要在 php.ini 中包含 GD2 DLL php_gd2.dll。 并且您还需要包含 php_fileinfo.dll 和 php_mbstring.dll 以满足 mews/captcha 依赖项的要求。
        用法：
            1. 在引导 Laravel 应用程序时注册该提供程序
                找到 providers 键 在 config/app.php 并注册验证码服务提供商。
                    'providers' => [
                        // ... 
                        Mews \ Captcha \ CaptchaServiceProvider ::class,
                    ]
                找到aliases里面的键 在 config/app.php。
                    'aliases' => [
                        // ... 
                        'Captcha' => Mews \ Captcha \ Facades \ Captcha ::class,
                    ]
            2. 自定义设置：
                要使用您自己的设置，请发布配置。
                    $ php artisan vendor:publish
                命令执行后 会生成 config/captcha.php 文件
            
            3. 禁用验证：
                要禁用验证码验证，请使用CAPTCHA_DISABLE环境变量。例如 .env 配置：
                CAPTCHA_DISABLE = true

2. 案例
    在视图文件 resources\views\home\test\test13.blade.php 中，加入
        <p>验证码：<input type="text" name="captcha"><img src="{{ captcha_src()}}"></p>
    在 控制器文件 app\Http\Controllers\TestController.php 中加入 
        //自动验证
        public function test13(Request $request){
            // 判断请求类型
            // echo Input::method();
            if (Input::method() == 'POST'){
                // 自动验证
                $this->validate($request,[
                    // 具体的规则
                    // 字段 => 验证规则1|验证规则2|验证规则3|...
                    'name'      => 'required|min:2|max:20',
                    'age'       => 'required|integer|min:1',
                    'email'     => 'required|email',
                    'captcha'   => 'required|captcha'               // 这里加入 规则 进行 验证
                ]);
                echo '输入的信息 没有问题';
            }else{
                // 展示视图
                return view('home.test.test13');
            }
        }
    注意：
        验证码有效性 验证规则，手册里是没有的，如果使用 mews 验证码包 的话，其验证码 验证规则 就是 captcha

*+++++* 数据表的迁移与填充
    迁移：创建数据表的操作 + 删除数据表的 操作
    填充：往数据表里 填充 写入 测试的数据（数据的插入操作）

1. 数据的迁移操作
    在迁移过程中，操作可以分为两个部分：创建 与 编写迁移文件、执行迁移文件
    1. 迁移文件的创建与编写
        迁移文件默认的位置。
            database\migrations 目录下的文件 全都是 迁移文件
            已经存在的 2 个文件，如果不打算使用 系统 自带的 认证模块 的话，需要删除掉。不然会 自动 给我们数据库 创建 2 张表。
        1. 创建迁移文件
        案例：需要 创建 试卷 的数据表，假设 数据表 名字是 paper。则迁移文件名可以写成：create_paper_table
        创建的时候可以通过 自动代码生成工具 artisan 命令来执行 迁移文件的 生成。
            php artisan make:migration 迁移文件名           // creat a new migration file
            如：
                php artisan make:migration create_paper_table
    2. 编写 迁移文件 代码，让其能够实现 数据表的 创建（up方法）和 删除（donw方法）
        在写之前，可以参考项目初始化 提供的 user 迁移文件
        
        Schema 门面（类）是用于操作数据表的门面，调用 其 具体的方法之后 就可以实现创建数据表 与 删除 数据表。
        试卷表的 字段分析：
            id              表的主键，自增
            paper_name      试卷名称，唯一，varchar(100)，不为空
            tatal_score     试卷总分，整型数字，tinyint，默认为 100
            start_time      试卷开始考试时间，时间戳类型（整型 int）
            duration        考试时间长度，单位分钟，整型 tinyint
            status          试卷是否启用的状态，1 表示 启用，2 表示 禁用，默认 为 1，tinyint 类型
        在创建数据表的列的时候遵循语法：
            $table 表示 整个表 的实例
            $table -> 列类型方法(字段名, [长度/值 范围]) -> 列修饰方法([修饰的值])

        常用的列的类型：https://learnku.com/docs/laravel/5.3/migrations/1189 文档介绍
            $table -> string('email')                           等同于数据库中的 varchar 列 
            $table -> string('email', 100)                      等同于数据库中的 varchar 列 带个 长度
            $table -> increment('id')                           等同于数据库中的 主键自增 ID
            $table -> tinyInteger('age')                        等同于数据库中的 TINYINT 类型
            $table -> integer('votes')                          等同于数据库中的 INTEGER 类型
            $table -> enum('choices', ['foo','bar'])            等同于数据库中的 ENUM 类型

        常用的列修饰方法：
            $table -> after('column')	                        将此字段放置在其它字段「之后」（仅限 MySQL）
            $table -> comment('my comment')	                    增加注释
            $table -> default($value)	                        为此字段指定「默认」值
            $table -> first()	                                将此字段放置在数据表的「首位」（仅限 MySQL）
            $table -> nullable()	                            此字段允许写入 NULL 值
            $table -> storedAs($expression)	                    创建一个存储的生成字段 （仅限 MySQL）
            $table -> unsigned()	                            设置 integer 字段为 UNSIGNED
            $table -> virtualAs($expression)	                创建一个虚拟的生成字段 （仅限 MySQL）


        创建 数据表 迁移的 代码：
            在 database\migrations\2024_02_24_130918_create_paper_table.php 文件中 编写

    2. 执行迁移文件
        执行 分为 up 和 down
        Up 方法的执行：
            如果 在 当前的项目中第一次执行迁移文件的话，则需要先去执行；
            命令：
                php artisan migrate:install
            作用： 
                这个命令执行完成后，会在数据库中 创建出一个 表名为 migration 的表
                table migration (
                    id          : 序号
                    migration   : 已经执行过的 迁移文件名
                    batch       : 批次号，执行的序号
                )
                migration 表 用于创建 记录 迁移文件的记录 数据表
            需要执行 up 方法，则需要执行命令：（注意：需要删除系统 自带的 迁移文件，只保留自己的）
                php artisan migrate
            作用：
                这个命令 执行完成后，
                会 在数据库中 的 迁移记录表 migration 中增加一条记录信息
                同时 产生了 paper 表
        
        Down 方法执行：（回滚操作，删除数据表）
            php artisan migrate:rollback           【回滚最后一次的迁移操作】
        注意：
            删除（回滚）之后 
            会删除 上一个 批次的 迁移记录，
            并且 同批次建立的数据表 也会被 删除，
            但是 迁移文件 依旧存在，方便后期 继续迁移（创建 数据表）

2. 数据表填充器
    填充操作 就是 往数据表中 写测试数据 的操作
    1. 填充器（种子文件）的创建与编写
        1. 填充器默认的所在目录
            database\seeds 目录
        2. 创建填充器
            php artisan make:seeder 填充器名称      【约定俗成的写法：大写表名+TableSeeder】
            例如：
                以 paper 表为例，则名称应该为 PaperTableSeeder
            创建 好 的 种子 文件：
                php artisan make:seeder PaperTableSeeder
        3. 编写填充器的代码，实现 往数据表 中 写入数据    【重点】
            注意：
                在填充器文件中 可以使用 DB 门面去新增数据，
                但是 需要注意，DB门面 在使用的时候 不需要用户自己引入，一旦引入则报错，可以直接使用
            public function run() {
                //定义数组
                $data = [
                    [
                        'paper_name'    => '文综',
                        'start_time'    => strtotime('+7 days'),
                        'duration'      => '120',
                    ],
                    [
                        'paper_name'    => '理综',
                        'start_time'    => strtotime('+7 days'),
                        'duration'      => '120',
                    ],
                    [
                        'paper_name'    => '英语',
                        'start_time'    => strtotime('+7 days'),
                        'duration'      => '120',
                    ],
                ];
                // 写入数据
                DB::table('paper') -> insert($data);
            }

    2. 执行填充器文件
        命令：
            php artisan db:seed --class=需要执行的种子文件名
        种子文件 不像迁移文件，有单独的对应关系表 去记录，由于 没有任何记录，
        所以在执行种子文件 的时候，需要指定执行的种子文件
            php artisan db:seed --class=PaperTableSeeder
        作用：
            执行之后 数据表 中的 对应的数据 就存在。
        注意：
            填充器的 执行操作 没有回滚一说，没有删除。
            如果需要回滚，则可以手动清空对应的数据表

*+++++* 项目初始化（使用laravel做项目）
1. 创建 laravel 项目
2. 建立数据库
3. 设置网站本地化为中文
4. 设置项目使用的时区
    修改系统默认 时区，
    修改 配置文件 ：config/app.php
        timezone 属性 修改为 Aisa/shanghai  Aisa/chongqing   PRC

5. 清理项目（删除不需要的文件）
    删除 app/Http/Controllers/Auth 目录，因为需要自定义登录逻辑
    删除 database\migrations 目录下 所有 默认自带的  迁移文件
    删除 database\seeds 目录 所有 默认自带的 初始种子文件
    删除 resources\views\welcome.blade.php 欢迎页面
    public 目录下 js、css 文件夹 也可以进行删除

6. 关闭 MySql 的严格模式
    编辑 config/database.php 将 strict 由 true 修改为 false
    严格模式的功能说明
        1. 不支持 not null 字段 插入 null 值
        2. 不支持 对 自增长字段 插入值
        3. 不支持 text 字段 有默认值

7. 安装 debugbar 工具条
    https://packagist.org/ 中下载 安装 使用

*+++++* 响应处理
    在 laravel 中，响应正常情况下有 2 个类型：常规的 直接响应，另一个是 Ajax 的响应。
    其中 展示 视图 以及直接响应字符串 都 属于常规的 响应
    例如：常规响应
        展示视图
            return view('welcome');
        直接返回某个字符串
            return 'hello world';

1. ajax 请求的响应
    常见的 ajax 响应数据类型：json 和 xml、text/html。
    案例：
        在页面中输出一个按钮，按钮要可以被点击，点击之后 发送 ajax 请求，请求后台的数据，后台返
        回 前端 ajax 一个 json 的数据（不要使用 json_encode() 内置php的函数）

        创建路由            
            //响应方式
            Route::get('/home/test/test16', 'TestController@test17');
            Route::get('/home/test/test16', 'TestController@test17');
        创建需要的 视图文件  resources\views\home\test\test16.blade.php 和 resources\views\home\test\test17.blade.php
            其中 test16 主要 展示 视图页面，
                 test17 负责 ajax 响应
            // ajax 页面展示
            public function test16(Request $request) {
                return view('home.test.test16');
            }
            // ajax 的响应
            public function test17(Request $request) {
                return 'hello';
            }
        创建视图，并且将 视图的效果实现 如案例描述一样（引入jQuery）
            <script type="text/javascript" src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
        点击 按钮 之后 能够 产生 一个 ajax 请求
            发送 ajax 请求：在 jQurey 中 4 种 发送 ajax 请求：
            1. $.get        ：$.get ( url地址, [ 参数对象, 回调函数, 期望的放回类型 ])
            2. $.post       ：$.post( url地址, [ 参数对象, 回调函数, 期望的放回类型 ])
            3. $.ajax       ：$.ajax(obj)                                   参数 只有 一个，就是 参数的 对象
            4. $.getJSON    ：$.getJSON( url地址, [ 参数对象, 回调函数])；    该方法 一般用于解决 跨域请求

            <script type="text/javascript">
                // jQuery 的 页面 载入 事件
                $(function(){
                    // 给按钮 绑定 点击事件
                    $('#btn').click(function()){
                        //发送 ajax 请求
                        $.get('/home/test/test7', function(data){
                            console.log('hwllo');
                        }, 'json');
                    }
                })
            </script>
        响应处理 【重点】
            在 laravel 中 框架 如果需要响应 json 数据，则写成
            return response()->json(需要 json 输出的 数据);
            
            // ajax 页面展示
            public function test16(Request $request) {
                return view('home.test.test16');
            }
            // ajax 的响应
            public function test17(Request $request) {
                // 查询 数据
                $data = Member::all();
                // json格式 响应
                // return json_encode($data);
                return response()->json($data);
                // return '{ "aa": "hello test17"}';
            }
        补充：
            在 laravel 中 布尔值 是不能被 直接 通过 return 响应输出的。

2. 跳转响应（重定向）
    在有一些 页面，例如同步添加操作，完成 操作之后不能 停留在 当前页面，最好做 一个跳转 操作，也就是 需要一个 跳转的 响应
    以 之前 “上传文件”（test14.blade.php） 操作代码为例：
        后续 比较理想的 情况应该是在 处理完成之后 需要 一个 跳转提示。告知 用户 是否成功，成功则应该 返回上一页，失败输出提示。
    两个跳转方式 任选一个：
        return redirect(路由);
        return redirect() -> to(路由);
    例如：
        //文件上传
        public function test14(Request $request){
            // 判断请求类型
            if (Input::method() === 'POST'){
                // 获取 传送过来的 文件信息 使用 $_FILES
                // dd($_FILES);
                
                // dd($request->file('avatar'));
                if ($request -> hasFile('avatar') && $request -> file('avatar') -> isValid() ) {
                    // 获取 文件的 原始 名称
                    // dd($request->file('avatar')->getClientOriginalName());
                    // 获取文件的 大小 单位 Byte
                    // dd($request->file('avatar')->getClientSize());
                    $houZhui = $request->file('avatar')->getClientOriginalExtension();
                    $filePath = md5(time() . rand(100000, 99999)) . '.' . $houZhui;
                    $request->file('avatar')->move('./uploads',  $filePath);

                    // 获取全部的数据
                    $data = $request->all();
                    // dd($data);
                    // 此时 $data 里的 avatar 属性中的 值 是一个 Illuminate\Http\UploadedFile 对象
                    $data['avatar'] = './uploads/' . $filePath;  // 这里 将  $data 里的 avatar 属性 的值 重新赋值 为 文件名 字符串
                    // dd($data);
                    $res = Member::create($data);
                    // dd($res);
                    if ($res == true) {
                        return redirect('/');                       // 这里 跳转响应（重定向）到 “/” 根 目录
                    }
                }
            }else{
                // 展示视图
                return view('home.test.test14');
            }
        }


*******************    Day04    ******************

*+++++* 会话控制
    常见应用 - 增删改查
    session 默认存到文件中
    session 文件目录：storage/framework/sessions
1. 使用 session 门面
    控制器 头部引用 use Illuminate/Support/Facades/Session;
    由于 session 门面在 app.php 中 已经定义好 别名，所以在控制器 中 引入的时候 可以直接 use Session;
    常用的 静态方法：
        Session::put('key', 'value');               Session 中存储 一个 变量
        $value = Session::get('key');               Session 中获取 一个 变量
        $value = Session::get('key', 'defaultValue');               Session 中获取 一个 变量 或 返回 一个 默认值（如果变量不存在）
        $value = Session::get('key', function(){ return 'default';});
        Session::all();                             Session 中获取所有变量
        Session::has('users');                      检查一个变量是否 在 Session 中 存在
        Session::forget('key');                     Session 中 删除一个变量
        Session::flush();                           Seesion 中 删除 所有变量
        补充：session 方法 也可以 在视图中使用，如：{{ $session::get('code') }}
    案例：
        把 上述 的 Session 方法 用 一遍。
        创建路由 和 方法：
            // 会话 控制
            Route::get('/home/test/test18', 'TestController@test18');
            
            // 会话控制
            public function test18(Request $request) {
                return view('home.test.test18');
            }

            // 会话控制
            public function test18(Request $request) {
                //Session 中存储 一个 变量
                Session::put('name', '路飞');               
                //Session 中获取 一个 变量
                $value = Session::get('name');               
                //Session 中获取 一个 变量 或 返回 一个 默认值（如果变量不存在）
                $value = Session::get('gender', '保密');               
                $value = Session::get('gender', function(){ return '男';});
                //Session 中获取所有变量
                Session::all();                             
                //检查一个变量是否 在 Session 中 存在
                Session::has('name');                      
                //Session 中 删除一个变量
                Session::forget('name');                     
                //Seesion 中 删除 所有变量
                Session::flush();                           
            }

*+++++* 缓存操作
    laravel 为 不同的 缓存 系统 提供了统一的 API。缓存配置与 config/cache.php。
    在 该文件中你可以指定在 应用中 默认使用 哪个 缓存驱动。
    如：
        'default' => env('CACHE_DRIVER', 'file'),
    laravel 目录 支持 主流的 缓存后端
    如：Memcached、Redis 等。
    主要方法：
        Cache::put()
        Cache::get()            发现 ：使用 dd( Cache::get('xixixiyi')); 打印 时 会立即 删除 缓存项
        Cache::add()
        Cache::pull()
        Cache::(forever)
        Cache::forget()
        Cache::has()
    系统 默认 使用 文件 缓存，其缓存文件 储存位置在 ：storage\framework\cache\data
    1. 设置缓存
        语法：Cache::put('key', 'value', $minutes);
        注意：如果该键 已经存在，则直接覆盖原来的值，有效期 必须设置，单位是 分钟

        语法：Cache::add('key', 'value', $minutes);
        add 方法 只会在 缓存项 不存在 的情况下 添加数据 到 缓存，如果 数据 被添加到缓存 返回 true，否则 返回 false

        永久存储数据
        forever 方法用于 持久化 存储数据到 缓存，这些值 必须通过 forget 方法 手动从 缓存 中移除
        Cache::forever('key', 'value');
    2. 获取 缓存数据
        Cache 门面的 get 方法 用于 从缓存中 获取 缓存项，如果缓存项 不存在，返回 null。如果需要的话 可以 传递 第二个 参数
        到 get 方法 指定 缓存项 不存在时 返回 的 自定义默认值
        $value = Cache::get('key');
        $value = Cache::get('key', 'default');
        可以 传递一个匿名函数 作为 默认值，如果缓存 项 不存在的话，闭包的结果 将会 被返回。传递匿名函数 允许 你可以从数据库
        或 其他 外部服务 获取默认值。
        $value = Cache::get('key', function(){
            return DB::table(...)->get();
        });
        检查缓存项 是否 存在
        has 方法 用于 判断 缓存项 是否存在
        if (Cache::has('key')){
            //...
        }
    3. 删除缓存数据
        语法：
            $value = Cache::pull('key'); 从缓存中 获取 缓存项 然后 删除，如果缓存项 不存在的话 返回 null，设置一次性的缓存项 时 使用。
            Cache::forget('key'); 使用  forget 方法 从缓存中 移除 缓存项数据
            Cache::flush(); 使用 flush 方法 清除 所有 缓存，并且删除对应的 目录
    4. 缓存数值 增加 / 减少
        increment 和 decrement 方法 可以 用于 调整 缓存中 的 整型数值。这 两个方法 都可以 接收 第二个参数 来
        指明 缓存项 数值 增加 和 减少 的 数值。
        Cache::increment('key');
        Cache::increment('key', $amount);
        Cache::decrement('key');
        Cache::decrement('key', $amount);
    5. 获取并存储
        有时候可能 想要 获取 缓存项，但是 如果请求的 缓存项 不存在 时 给它 存储一个 默认值。
        例如，可能想要 从缓存中给获取 所有用户，或者 如果 他们 不存在的话， 
        从数据库获取他们 并 将其 添加 到 缓存中，可以使用 Cache::remember() 方法实现。
        $value = Cache::remember('user', $minites, function(){
            return DB::table('users')->get();
        });
        如果缓存项 不存在，传递给 remember 方法的闭包 被执行 并且将结果存放 到缓存中

        还可以 联合 remember 和 forever 方法：
        $value = Cache::rememberForever('users', function(){
            return DB::table('users')->get();
        });

    案例：
        添加 路由 及 方法：
            // 缓存 操作
            Route::get('/home/test/test19', 'TestController@test19');
            
            // 使用 Cache 方法，需要 先 引入 ：use Cache;
            // 缓存 操作
            public function test19(Request $request) {
                return 'hello 19';
            }

*+++++* 联表查询
*+++++* 关联模型（重点 + 难点）
